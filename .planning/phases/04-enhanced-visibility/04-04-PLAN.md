---
phase: 04-enhanced-visibility
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - dashboard/src/pages/Queue.tsx
  - dashboard/src/pages/Queue.module.css
  - dashboard/src/pages/AppDetailRepoTable.tsx
  - dashboard/src/pages/AppDetail.tsx
  - dashboard/src/pages/AppDetail.module.css
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Queue page has search and status filter with client-side sorting"
    - "Queue jobs table uses DataTable with sortable column headers"
    - "AppDetail repository sub-table has search, status filter, sortable columns, and client-side pagination"
    - "Filtered empty states show 'No results match your filters' with clear button on both pages"
  artifacts:
    - path: "dashboard/src/pages/Queue.tsx"
      provides: "Queue page with client-side filtering and sorting"
      contains: "DataTable"
    - path: "dashboard/src/pages/AppDetailRepoTable.tsx"
      provides: "App detail repo table with filtering, sorting, pagination"
      contains: "DataTable"
  key_links:
    - from: "dashboard/src/pages/Queue.tsx"
      to: "dashboard/src/components/DataTable.tsx"
      via: "DataTable import for sortable job table"
      pattern: "DataTable"
    - from: "dashboard/src/pages/AppDetailRepoTable.tsx"
      to: "dashboard/src/components/Pagination.tsx"
      via: "Pagination for client-side paging of repo list"
      pattern: "Pagination"
---

<objective>
Add filtering, sorting, and pagination to Queue page (client-side) and AppDetail repository sub-table.

Purpose: Queue jobs come from BullMQ Redis and cannot be sorted server-side. AppDetail's repositories come embedded in the app detail response. Both need client-side filtering/sorting/pagination using the same shared components for consistent UX.

Output: Queue page with search/filter/sort and AppDetail repo sub-table with search/filter/sort/pagination.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-enhanced-visibility/04-RESEARCH.md
@.planning/phases/04-enhanced-visibility/04-01-SUMMARY.md
@.planning/phases/04-enhanced-visibility/04-02-SUMMARY.md

@dashboard/src/pages/Queue.tsx
@dashboard/src/pages/AppDetailRepoTable.tsx
@dashboard/src/pages/AppDetail.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Queue page with client-side filtering and sorting</name>
  <files>
    dashboard/src/pages/Queue.tsx
    dashboard/src/pages/Queue.module.css
  </files>
  <action>
    Add search, status filter, and sortable column headers to the Queue page. All filtering and sorting is CLIENT-SIDE because BullMQ does not support SQL-like ORDER BY.

    **Queue.tsx rewrite:**
    1. Import: `DataTable` + `Column`, `FilterBar` + `FilterConfig`, `FilterChips` from shared components. Import `useState`, `useMemo` from React. Do NOT use `useTableParams` (no URL state sync needed for client-side — queue data is ephemeral and small).
    2. Keep existing `usePollingQuery(['queue'], fetchQueue)` — no pagination changes to the API.
    3. Add local state: `searchTerm`, `statusFilter`, `sortBy` (default: ''), `sortOrder` (default: 'desc' as const)
    4. Define status filter config:
       ```
       const statusFilter: FilterConfig = {
         key: 'status', label: 'Status',
         options: [
           { value: 'active', label: 'Active' },
           { value: 'waiting', label: 'Waiting' },
           { value: 'delayed', label: 'Delayed' },
         ]
       }
       ```
    5. Apply client-side filtering with `useMemo`:
       - Filter by status if statusFilter is set
       - Filter by search (case-insensitive match on app_name and repository_name)
    6. Apply client-side sorting with `useMemo`:
       - If sortBy is set, sort filtered jobs by the selected column
       - Support sorting by: repository_name, app_name, status, created_at
       - For status sorting: use priority order (active=0, waiting=1, delayed=2)
       - For created_at: compare Date values
       - For strings: localeCompare
    7. Define columns: `Column<QueueJob>[]`:
       - Repository (key: 'repository_name', sortable)
       - App (key: 'app_name', sortable)
       - Status (key: 'status', sortable, render: JobStatusBadge — keep existing inline component)
       - Created (key: 'created_at', sortable, render: formatDistanceToNow)
    8. Sort handler: same cycling pattern as other pages but updates local state instead of URL
    9. Keep status cards section at top (Active, Waiting, Delayed, Completed, Failed counts) — unchanged
    10. Replace the `<table>` in "Current Jobs" section with FilterBar + FilterChips + DataTable
    11. No Pagination needed — queue jobs are already limited to 50 server-side
    12. Filtered empty state: "No jobs match your filters" with clear button
    13. Regular empty state (no filters): keep existing "No active or waiting jobs" message

    **Queue.module.css update:**
    - Remove `.table`, `thead`, `th`, `td`, `tr` styles (handled by DataTable)
    - Keep all `.statusGrid`, `.statusCard`, `.statusLabel`, `.statusValue`, `.statusActive`, `.statusWaiting`, `.statusDelayed`, `.statusCompleted`, `.statusFailed` styles
    - Keep `.container`, `.header`, `.title`, `.section`, `.sectionTitle`, `.refreshInfo`, `.refreshButton`, `.loadingState`, `.spin`, `.emptyJobs`
    - Keep `.jobStatusBadge`, `.jobActive`, `.jobWaiting`, `.jobDelayed` styles
  </action>
  <verify>
    Run `cd /home/toto/scm-projects/docora/dashboard && pnpm exec tsc --noEmit`.
  </verify>
  <done>
    Queue page shows status cards + filterable/sortable jobs table. Search filters by app/repo name. Status dropdown filters by job status. Column headers sort client-side. No server-side changes needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: AppDetail repository sub-table with filtering, sorting, and pagination</name>
  <files>
    dashboard/src/pages/AppDetailRepoTable.tsx
    dashboard/src/pages/AppDetail.tsx
    dashboard/src/pages/AppDetail.module.css
  </files>
  <action>
    Add search, status filter, sorting, and CLIENT-SIDE pagination to the AppDetail repository sub-table. The repositories come embedded in the AppDetail response so pagination is client-side.

    **AppDetailRepoTable.tsx rewrite:**
    1. Import: `DataTable` + `Column`, `Pagination`, `FilterBar` + `FilterConfig`, `FilterChips` from shared components. Import `useState`, `useMemo` from React.
    2. Keep existing Props interface but note: repositories come from parent as full array
    3. Add local state: `searchTerm`, `statusFilter`, `sortBy` (default: 'name'), `sortOrder` (default: 'asc'), `page` (default: 1), `limit` (default: 20)
    4. Apply client-side filtering with `useMemo`:
       - Filter by status if set
       - Filter by search on `owner/name` (case-insensitive)
    5. Apply client-side sorting with `useMemo`:
       - Sort by selected column (name, status, last_scanned_at)
       - Handle null last_scanned_at (sort nulls last)
    6. Apply client-side pagination with `useMemo`:
       - Compute total/totalPages from filtered+sorted array
       - Slice for current page
    7. Define columns: `Column<RepositorySummary>[]`:
       - Repository (key: 'name', sortable, render: GitHub link + circuit badge)
       - Status (key: 'status', sortable, render: StatusBadge — keep existing)
       - Last Scanned (key: 'last_scanned_at', sortable, render: formatDistanceToNow)
       - Actions (key: 'actions', not sortable, render: Retry + Re-sync buttons using existing mutations from props)
    8. Define status filter config (same 4 statuses as Repositories page)
    9. Sort handler: updates local state, resets page to 1
    10. Filter/search change: resets page to 1
    11. Render: FilterBar + FilterChips + DataTable + Pagination (only show Pagination when totalPages > 1)
    12. Filtered empty state vs regular empty state
    13. Keep all existing action button behavior (retry, resync from props)

    **AppDetail.tsx minimal changes:**
    - No structural changes needed — AppDetailRepoTable handles its own filtering internally
    - Remove any `app.repositories` length display that would be incorrect after filtering (check "Repositories" section header)
    - The "Retry All Failed" count should still use `app.failed_notification_count` from the API (total, not filtered)
    - The "Re-sync All Repos" count should still use `app.repository_count` from the API (total, not filtered)

    **AppDetail.module.css:**
    - Remove `.table`, `thead`, `th`, `td`, `tr` styles from AppDetail.module.css (now handled by DataTable)
    - Keep all other styles including `.statusBadge`, `.statusSynced`, `.statusFailed`, `.statusPending`, `.statusScanning`, `.circuitBadge`, `.repoLink`, `.retryButton`, `.resyncButton`, `.actionsCell`
  </action>
  <verify>
    Run `cd /home/toto/scm-projects/docora/dashboard && pnpm exec tsc --noEmit`.
  </verify>
  <done>
    AppDetail repo sub-table has search, status filter, sortable columns, and client-side pagination. All retry/resync action buttons still work. Bulk operation counts use API totals not filtered counts. Pagination only shows when there are multiple pages.
  </done>
</task>

</tasks>

<verification>
- Queue page compiles and shows sortable/filterable jobs table
- AppDetailRepoTable compiles and shows search/filter/sort/pagination
- Client-side sorting correctly handles all data types (strings, dates, null values)
- Existing retry/resync actions on AppDetail still functional
- Filtered empty states work correctly on both pages
- Status filter dropdown matches the correct status values for each page
</verification>

<success_criteria>
Queue page and AppDetail sub-table have consistent search, filter, and sort UX using shared components. Client-side implementation is appropriate for both (BullMQ limitation for Queue, embedded data for AppDetail). All existing action buttons continue to work.
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-visibility/04-04-SUMMARY.md`
</output>
