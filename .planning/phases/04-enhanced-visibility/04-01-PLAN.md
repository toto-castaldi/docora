---
phase: 04-enhanced-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared-types/src/dashboard.ts
  - src/repositories/pagination.ts
  - src/routes/admin/query-params.ts
  - src/repositories/admin-dashboard.ts
  - src/routes/admin/dashboard-api.ts
  - src/routes/admin/dashboard-api-apps.ts
  - src/routes/admin/dashboard-api-repos.ts
  - src/routes/admin/dashboard-api-notifications.ts
  - src/routes/admin/dashboard-api-queue.ts
  - deploy/liquibase/changelog/007-dashboard-indexes.yml
  - deploy/liquibase/changelog/db.changelog-master.yml
  - dashboard/src/api/admin.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /admin/api/apps accepts page, limit, sort_by, sort_order, search params and returns PaginatedResponse"
    - "GET /admin/api/repositories accepts page, limit, sort_by, sort_order, search, status params and returns PaginatedResponse"
    - "GET /admin/api/notifications/failed accepts page, limit, sort_by, sort_order, search params and returns PaginatedResponse"
    - "GET /admin/api/queue returns jobs with client-side sort/filter support (unchanged response shape for status)"
    - "sort_by parameter is validated against a whitelist per endpoint — invalid values return 400"
    - "Search uses ILIKE across multiple fields per endpoint"
    - "Count and data queries share identical WHERE clauses"
  artifacts:
    - path: "src/repositories/pagination.ts"
      provides: "Reusable paginateQuery helper for Kysely"
      exports: ["paginateQuery", "PaginatedResult", "PaginationParams"]
    - path: "src/routes/admin/query-params.ts"
      provides: "Query parameter parser with validation"
      exports: ["parseQueryParams", "ParsedQueryParams"]
    - path: "packages/shared-types/src/dashboard.ts"
      provides: "PaginatedResponse type and ListQueryParams"
      contains: "PaginatedResponse"
    - path: "deploy/liquibase/changelog/007-dashboard-indexes.yml"
      provides: "Database indexes for status and last_scanned_at"
      contains: "createIndex"
  key_links:
    - from: "src/routes/admin/dashboard-api-apps.ts"
      to: "src/repositories/pagination.ts"
      via: "paginateQuery import"
      pattern: "paginateQuery"
    - from: "src/routes/admin/dashboard-api-apps.ts"
      to: "src/routes/admin/query-params.ts"
      via: "parseQueryParams import"
      pattern: "parseQueryParams"
---

<objective>
Add server-side pagination, sorting, and search to all admin dashboard API endpoints.

Purpose: Backend infrastructure for Phase 4 — every admin list endpoint needs to accept pagination/sort/search params and return paginated results with total counts. This is the foundation that all frontend pages will consume.

Output: Paginated API endpoints, shared types, pagination helper, query parser, database indexes.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-enhanced-visibility/04-RESEARCH.md

@packages/shared-types/src/dashboard.ts
@src/repositories/admin-dashboard.ts
@src/routes/admin/dashboard-api.ts
@src/services/queue-status.ts
@deploy/liquibase/changelog/db.changelog-master.yml
@dashboard/src/api/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared types, pagination helper, and query parser</name>
  <files>
    packages/shared-types/src/dashboard.ts
    src/repositories/pagination.ts
    src/routes/admin/query-params.ts
    deploy/liquibase/changelog/007-dashboard-indexes.yml
    deploy/liquibase/changelog/db.changelog-master.yml
  </files>
  <action>
    1. **Shared types** — Add to `packages/shared-types/src/dashboard.ts`:
       - `PaginatedResponse<T>` interface: `{ data: T[]; pagination: { page: number; limit: number; total: number; total_pages: number; } }`
       - `ListQueryParams` interface: `{ page?: string; limit?: string; sort_by?: string; sort_order?: string; search?: string; }`
       - Keep ALL existing types unchanged (AppSummary, RepositorySummary, etc.)

    2. **Pagination helper** — Create `src/repositories/pagination.ts`:
       - Export `PaginationParams` interface: `{ page: number; limit: number; }`
       - Export `PaginatedResult<T>` interface matching the frontend type shape
       - Export `paginateQuery<DB, TB extends keyof DB, O>` async function that takes a Kysely `SelectQueryBuilder`, page, and limit
       - Implementation: compute `offset = (page - 1) * limit`, run TWO parallel queries from the base query:
         - Count query: `baseQuery.clearSelect().select((eb) => eb.fn.countAll().as('total')).executeTakeFirstOrThrow()`
         - Data query: `baseQuery.limit(limit).offset(offset).execute()`
       - Return `{ data, pagination: { page, limit, total: Number(countResult.total), total_pages: Math.ceil(total / limit) } }`
       - **Important:** Kysely 0.28.9 supports `clearSelect()`. Use it.

    3. **Query parameter parser** — Create `src/routes/admin/query-params.ts`:
       - Export `ParsedQueryParams` interface: `{ page: number; limit: number; sort_by: string; sort_order: 'asc' | 'desc'; search: string; }`
       - Export `parseQueryParams(query, defaults)` function:
         - `page`: parse int, clamp to min 1, default 1
         - `limit`: parse int, validate against `[20, 50, 100]`, default 20
         - `sort_order`: must be 'asc' or 'desc', default from `defaults.sort_order`
         - `sort_by`: take raw value (validation happens per-endpoint with whitelist)
         - `search`: trim, default empty string
       - Export `validateSortColumn<T extends Record<string, string>>(sortBy: string, allowedColumns: T): string | null` — returns the mapped DB column or null if invalid

    4. **Database migration** — Create `deploy/liquibase/changelog/007-dashboard-indexes.yml`:
       - Add index on `app_repositories.status` (idx_app_repositories_status)
       - Add index on `app_repositories.last_scanned_at` (idx_app_repositories_last_scanned_at)
       - Update `db.changelog-master.yml` to include the new file
  </action>
  <verify>
    Run `pnpm typecheck` to verify shared types compile. Verify the migration YAML is valid syntax.
  </verify>
  <done>
    PaginatedResponse type exists in shared-types, paginateQuery helper is importable, parseQueryParams is importable, migration file exists and is referenced in master changelog.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify all backend API endpoints for pagination</name>
  <files>
    src/repositories/admin-dashboard.ts
    src/routes/admin/dashboard-api.ts
    src/routes/admin/dashboard-api-apps.ts
    src/routes/admin/dashboard-api-repos.ts
    src/routes/admin/dashboard-api-notifications.ts
    src/routes/admin/dashboard-api-queue.ts
  </files>
  <action>
    **Refactor dashboard-api.ts** — The current file is 213 lines with all endpoints. Split into focused route files following the 150-line rule. The main `dashboard-api.ts` becomes a registrar that imports and registers sub-route plugins.

    1. **Modify `src/repositories/admin-dashboard.ts`** — Convert list functions to accept pagination/filter params:
       - `listAppsWithCounts(params)`: Accept `{ page, limit, sort_by, sort_order, search }`. Build base query with LEFT JOIN as-is. Add ILIKE search on `apps.app_name` and `apps.base_url` when search is provided. Apply sort via `orderBy` (whitelist: `app_name -> apps.app_name`, `created_at -> apps.created_at`). For `repository_count` and `failed_notification_count` sorting — these are computed via aggregation, so order by the alias directly. Use `paginateQuery` for pagination. Return `PaginatedResult<AppWithCounts>`.
       - `listAllRepositories(params)`: Accept same pagination params + `status` filter. Add WHERE for status filter when provided. Add ILIKE search on `repositories.owner`, `repositories.name`, `repositories.github_url`. Whitelist sort columns: `name -> repositories.name`, `status -> app_repositories.status`, `last_scanned_at -> app_repositories.last_scanned_at`, `created_at -> repositories.created_at`. Use `paginateQuery`.
       - `listFailedNotifications(params)`: Accept pagination params. Add ILIKE search on `apps.app_name`, `repositories.owner || '/' || repositories.name` (or search both owner and name separately), `app_repositories.last_error`. Whitelist sort: `app_name -> apps.app_name`, `repository_name -> repositories.name`, `retry_count -> app_repositories.retry_count`, `last_scanned_at -> app_repositories.last_scanned_at`. Use `paginateQuery`.
       - Keep `getAppById`, `listRepositoriesByApp`, `getOverviewCounts` unchanged (not paginated).
       - **Important:** The sort column validation (whitelist check) should happen at the ROUTE level before calling repository. Pass already-validated column names to repository functions.

    2. **Create `src/routes/admin/dashboard-api-apps.ts`** — Extract apps endpoints:
       - `GET /admin/api/apps` with `Querystring: ListQueryParams` generic. Parse params with `parseQueryParams`, validate sort_by against whitelist `{ app_name, created_at, repository_count, failed_notification_count }`, return 400 for invalid sort_by. Call `listAppsWithCounts(params)`, map results to `AppSummary[]`, return `PaginatedResponse<AppSummary>`.
       - `GET /admin/api/apps/:appId` — move existing app detail logic here unchanged.

    3. **Create `src/routes/admin/dashboard-api-repos.ts`** — Extract repositories endpoint:
       - `GET /admin/api/repositories` with `Querystring: ListQueryParams & { status?: string }`. Parse params, validate sort_by whitelist `{ name, status, last_scanned_at, created_at }`, validate status against `['synced', 'failed', 'pending_snapshot', 'scanning']` if provided. Call `listAllRepositories(params)`, map, return `PaginatedResponse<RepositorySummary>`.

    4. **Create `src/routes/admin/dashboard-api-notifications.ts`** — Extract notifications endpoint:
       - `GET /admin/api/notifications/failed` with querystring. Parse params, validate sort_by whitelist `{ app_name, repository_name, retry_count, last_scanned_at }`. Call `listFailedNotifications(params)`, map, return `PaginatedResponse<FailedNotification>`.

    5. **Create `src/routes/admin/dashboard-api-queue.ts`** — Extract queue + overview endpoints:
       - `GET /admin/api/queue` — keep existing behavior (BullMQ client-side sort). NO pagination changes on this endpoint. Queue jobs from BullMQ are already limited to 50 and sorted client-side.
       - `GET /admin/api/overview` — move existing overview logic unchanged.

    6. **Update `src/routes/admin/dashboard-api.ts`** — Become a plugin registrar:
       - Keep the session auth hook at the top level
       - Register each sub-route plugin: `server.register(appsRoutes)`, `server.register(reposRoutes)`, etc.
       - Remove all inline route handlers

    **API response shape change:**
    - Apps, Repositories, Notifications: `{ data: T[] }` -> `{ data: T[], pagination: {...} }`
    - Queue and Overview: unchanged
    - AppDetail: unchanged (single object, not paginated)
  </action>
  <verify>
    Run `pnpm typecheck`. Run `pnpm build` to verify no import errors. If tests exist, run `pnpm test`.
  </verify>
  <done>
    All three paginated endpoints (apps, repositories, notifications) accept query params and return PaginatedResponse with correct pagination metadata. Invalid sort_by returns 400. Queue and overview endpoints unchanged. dashboard-api.ts is under 50 lines as a registrar.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update frontend API client for paginated responses</name>
  <files>
    dashboard/src/api/admin.ts
  </files>
  <action>
    Update the frontend API client functions to accept query params and handle paginated responses.

    1. **Add `PaginatedResponse` import** from `@docora/shared-types`.

    2. **Add `buildQueryString` helper** — Takes an object of key-value pairs, filters out empty/undefined values, returns `?key=value&...` string (or empty string if no params).

    3. **Modify `fetchApps`** — Accept `params?: { page?: number; limit?: number; sort_by?: string; sort_order?: string; search?: string }`. Build query string. Change return type from `AppSummary[]` to `PaginatedResponse<AppSummary>`. Use `fetchApi<PaginatedResponse<AppSummary>>` and return the FULL paginated response (not just `.data`).

    4. **Modify `fetchRepositories`** — Same pattern + accept `status?: string` filter param. Return `PaginatedResponse<RepositorySummary>`.

    5. **Modify `fetchFailedNotifications`** — Same pattern. Return `PaginatedResponse<FailedNotification>`.

    6. **Keep `fetchQueue`, `fetchAppDetail`, `fetchOverview` unchanged** — These are not paginated.

    **Important:** The `fetchApi` helper currently unwraps `ApiResponse<T>` by returning `data.data`. For paginated endpoints, the response IS `{ data: T[], pagination: {...} }`. Since `fetchApi` already does `response.json().data`, and the paginated response wraps with `{ data: { data: T[], pagination } }` ... actually NO. Check the backend: it does `reply.send({ data: response })` where response is already the mapped array. With pagination, it will be `reply.send({ data: paginatedResult.data, pagination: paginatedResult.pagination })`. So the outer wrapper is `ApiResponse<T[]>` but now with an extra `pagination` field.

    The cleanest approach: the backend should send `reply.send({ data: items, pagination })` and the frontend `fetchApi` still unwraps the outer `data` field. BUT pagination is a sibling of `data`. So `fetchApi` needs a variant that returns the full response body, not just `.data`.

    **Solution:** Create `fetchPaginatedApi<T>(endpoint)` that returns `{ data: T[], pagination }` — it reads the full response JSON without unwrapping. Alternatively, have the backend wrap as `reply.send({ data: { data: items, pagination } })` so `fetchApi` unwrapping gives `{ data: items, pagination }`. This is cleaner because it preserves backward compat.

    **Go with the wrapper approach:** Backend sends `{ data: { data: items, pagination } }` wrapped in ApiResponse. Frontend's existing `fetchApi<PaginatedResponse<T>>` returns `PaginatedResponse<T>` which has `{ data: T[], pagination }`. This works with existing code.
  </action>
  <verify>
    Run `cd /home/toto/scm-projects/docora/dashboard && pnpm exec tsc --noEmit` to verify frontend types compile.
  </verify>
  <done>
    fetchApps, fetchRepositories, and fetchFailedNotifications accept query params and return PaginatedResponse types. fetchQueue, fetchAppDetail, fetchOverview are unchanged. Frontend typechecks pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes with no errors
- `pnpm build` succeeds
- All admin API endpoints accept pagination query params
- Invalid sort_by returns HTTP 400
- Queue and overview endpoints are unmodified in behavior
- PaginatedResponse type is available in @docora/shared-types
</verification>

<success_criteria>
Backend serves paginated responses for apps, repositories, and notifications endpoints. Frontend API client updated to pass query params and receive paginated responses. Shared types include PaginatedResponse. Database indexes created for dashboard filtering performance.
</success_criteria>

<output>
After completion, create `.planning/phases/04-enhanced-visibility/04-01-SUMMARY.md`
</output>
