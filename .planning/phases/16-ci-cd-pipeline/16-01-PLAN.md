---
phase: 16-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .github/workflows/ci-deploy.yml
autonomous: true
requirements: [CI-01, CI-02, CI-03]

must_haves:
  truths:
    - "Pushing to main triggers a CI workflow that builds and pushes Docker images to ghcr.io"
    - "Docker images are tagged with a version extracted from STATE.md (not commit history)"
    - "Build metadata (run number, SHA, date) is accessible inside running containers via /version endpoint"
    - "Deploy step SSHs to production server and restarts services with the new images"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build that runs extract-version before compilation"
      contains: "extract-version.cjs"
    - path: ".github/workflows/ci-deploy.yml"
      provides: "Complete CI/CD pipeline: build-test, docker push, deploy"
      contains: "docker/build-push-action"
  key_links:
    - from: ".github/workflows/ci-deploy.yml"
      to: "scripts/extract-version.cjs"
      via: "CI runs extract-version to get version string for Docker tagging"
      pattern: "node scripts/extract-version.cjs"
    - from: "Dockerfile"
      to: "scripts/extract-version.cjs"
      via: "Docker builder stage runs extract-version with build args before pnpm build"
      pattern: "RUN.*extract-version"
    - from: ".github/workflows/ci-deploy.yml"
      to: "Dockerfile"
      via: "Docker build-push-action passes build-args for metadata"
      pattern: "BUILD_NUMBER.*BUILD_DATE"
---

<objective>
Rebuild the CI/CD pipeline so every push to main builds Docker images tagged with the STATE.md-derived version and deploys to the production server.

Purpose: Completes the versioning system by wiring the extract-version script into CI and Docker, replacing the old commit-analysis-based release flow with a simple push-to-deploy pipeline.

Output: Working CI/CD workflow that builds, tags, pushes, and deploys on every push to main.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/15-version-infrastructure/15-01-SUMMARY.md
@.planning/phases/14-toolchain-cleanup/14-02-SUMMARY.md

<interfaces>
<!-- Key contracts the executor needs. Extracted from codebase. -->

From scripts/extract-version.cjs:
- Reads milestone from `.planning/STATE.md` frontmatter (regex: `/^milestone:\s*v(\d+\.\d+)/m`)
- Env vars: `BUILD_NUMBER` and `COMMIT_SHA` control suffix (`1.0+42.abc1234` in CI, `1.0+dev` locally)
- Writes `src/version.ts` with baked `VERSION` and `BUILD_INFO` constants
- Syncs `package.json` version to `{major}.{minor}.0`
- Prints version string to stdout

From src/version.ts (generated):
```typescript
export const VERSION = "1.0+dev";
export const BUILD_INFO = {
  version: "1.0+dev",
  buildNumber: "dev",
  gitSha: "local",
  buildDate: "2026-02-26T08:31:27.704Z",
} as const;
```

From src/routes/version.ts:
```typescript
// GET /version returns: { version, buildNumber, gitSha, buildDate }
import { BUILD_INFO } from "../version.js";
```

Current Dockerfile structure:
- Stage 1 (builder): installs deps, copies source, runs `pnpm build && pnpm dashboard:build`
- Stage 2 (production): copies dist + dashboard/dist, runs as node user

Current CI workflow:
- `build-test` job: checkout, pnpm install, typecheck, test
- Docker/deploy jobs: commented out (preserved from Phase 14 for reference)

Commented docker job references (from ci-deploy.yml):
- Registry: ghcr.io
- IMAGE_NAME: ${{ github.repository }}
- Build args: BUILD_NUMBER, COMMIT_SHA, BUILD_DATE
- Docs image: ghcr.io/${{ github.repository }}-docs

Commented deploy job references:
- SCP: deploy/docker-compose.yml, deploy/caddy/Caddyfile, deploy/liquibase
- SSH: cd /opt/docora, docker compose pull, up -d --remove-orphans, restart caddy, prune
- Secrets: DEPLOY_HOST, DEPLOY_USER, DEPLOY_SSH_KEY

Deploy docker-compose.yml:
- docora-api: image ghcr.io/toto-castaldi/docora:latest
- docora-docs: image ghcr.io/toto-castaldi/docora-docs:latest
- docora-worker: same image as docora-api
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Dockerfile to run extract-version during build</name>
  <files>Dockerfile</files>
  <action>
Modify the Dockerfile builder stage to run `extract-version.cjs` before compiling, so the baked version.ts has real CI metadata.

Changes to the builder stage:
1. Add three `ARG` directives after the `WORKDIR /app` line: `ARG BUILD_NUMBER=dev`, `ARG COMMIT_SHA=local`, `ARG BUILD_DATE`
2. After `COPY src ./src` (and before the build command), add:
   - `COPY scripts ./scripts`
   - `COPY .planning/STATE.md .planning/STATE.md`
3. Replace the existing `RUN pnpm build && pnpm dashboard:build` with:
   ```
   RUN BUILD_NUMBER=${BUILD_NUMBER} COMMIT_SHA=${COMMIT_SHA} node scripts/extract-version.cjs && \
       pnpm build && pnpm dashboard:build
   ```

This ensures:
- In CI: BUILD_NUMBER and COMMIT_SHA are passed as build-args, producing version like `1.0+42.abc1234`
- In local docker build: defaults produce `1.0+dev` (same as current behavior)
- The generated version.ts is compiled into dist/ with baked values
- STATE.md is available for the extract script to read the milestone

No changes to the production stage — it already copies dist/ which now contains the correctly generated version.
  </action>
  <verify>
    <automated>docker build --build-arg BUILD_NUMBER=99 --build-arg COMMIT_SHA=abc1234def --no-cache -t docora-test:verify . 2>&1 | grep -E "(extract-version|Step|ERROR)" | head -20 && docker run --rm docora-test:verify node -e "import('./dist/version.js').then(m => console.log(JSON.stringify(m.BUILD_INFO)))" 2>&1 | grep -q "99" && echo "PASS: version baked correctly" || echo "FAIL: version not baked"</automated>
  </verify>
  <done>Dockerfile builder stage runs extract-version.cjs with build-args before compilation, producing baked version.ts with real CI metadata in the compiled output</done>
</task>

<task type="auto">
  <name>Task 2: Rebuild CI workflow with docker push and deploy jobs</name>
  <files>.github/workflows/ci-deploy.yml</files>
  <action>
Replace the commented-out docker and deploy sections in `.github/workflows/ci-deploy.yml` with active jobs. Keep the existing `build-test` job exactly as-is.

**Add a `docker` job** after `build-test`:

```yaml
docker:
    needs: build-test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
        contents: read
        packages: write
    outputs:
        version: ${{ steps.version.outputs.version }}
    steps:
        - uses: actions/checkout@v4

        - name: Setup Node.js
          uses: actions/setup-node@v4
          with:
              node-version: 22

        - name: Extract version from STATE.md
          id: version
          run: |
              VERSION=$(BUILD_NUMBER=${{ github.run_number }} COMMIT_SHA=${{ github.sha }} node scripts/extract-version.cjs)
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "Extracted version: $VERSION"

        - name: Log in to Container Registry
          uses: docker/login-action@v3
          with:
              registry: ${{ env.REGISTRY }}
              username: ${{ github.actor }}
              password: ${{ secrets.GITHUB_TOKEN }}

        - name: Build and push API image
          uses: docker/build-push-action@v6
          with:
              context: .
              push: true
              tags: |
                  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
                  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
              build-args: |
                  BUILD_NUMBER=${{ github.run_number }}
                  COMMIT_SHA=${{ github.sha }}
                  BUILD_DATE=${{ github.event.head_commit.timestamp }}

        - name: Build and push docs image
          uses: docker/build-push-action@v6
          with:
              context: ./docs-site
              push: true
              tags: |
                  ${{ env.REGISTRY }}/${{ github.repository }}-docs:${{ steps.version.outputs.version }}
                  ${{ env.REGISTRY }}/${{ github.repository }}-docs:latest
```

**Add a `deploy` job** after `docker`:

```yaml
deploy:
    needs: docker
    runs-on: ubuntu-latest
    steps:
        - uses: actions/checkout@v4

        - name: Copy files to server
          uses: appleboy/scp-action@v0.1.7
          with:
              host: ${{ secrets.DEPLOY_HOST }}
              username: ${{ secrets.DEPLOY_USER }}
              key: ${{ secrets.DEPLOY_SSH_KEY }}
              source: "deploy/docker-compose.yml,deploy/caddy/Caddyfile,deploy/liquibase"
              target: "/opt/docora"
              strip_components: 1

        - name: Deploy via SSH
          uses: appleboy/ssh-action@v1
          with:
              host: ${{ secrets.DEPLOY_HOST }}
              username: ${{ secrets.DEPLOY_USER }}
              key: ${{ secrets.DEPLOY_SSH_KEY }}
              script: |
                  cd /opt/docora
                  docker compose -f docker-compose.yml pull
                  docker compose -f docker-compose.yml up -d --remove-orphans
                  docker compose -f docker-compose.yml restart caddy
                  docker image prune -f
```

**Important details:**
- Remove ALL commented-out job blocks (the old `# docker:` and `# deploy:` sections). They are replaced by the new active jobs above.
- Remove the old comment header `# Docker and Deploy jobs disabled — Phase 16 will redesign with STATE.md-based versioning`
- The `docker` job uses `if: github.ref == 'refs/heads/main' && github.event_name == 'push'` so it only runs on main pushes (not PRs)
- The `docker` job requires `contents: read` (to checkout) and `packages: write` (to push to ghcr.io)
- The version is extracted BEFORE Docker build using the extract-version script with `BUILD_NUMBER` and `COMMIT_SHA` env vars
- Docker images get two tags: the version tag (e.g., `1.0+42.abc1234`) and `latest`
- Build args are passed through to Docker so the Dockerfile's extract-version step also bakes the correct values
- The deploy job depends on docker (sequential: build-test -> docker -> deploy)
- Deploy uses the exact same SCP paths and SSH commands from the old commented config
  </action>
  <verify>
    <automated>cd /home/toto/scm-projects/docora && python3 -c "
import yaml, sys
with open('.github/workflows/ci-deploy.yml') as f:
    wf = yaml.safe_load(f)
jobs = wf.get('jobs', {})
# Check all 3 jobs exist
assert 'build-test' in jobs, 'Missing build-test job'
assert 'docker' in jobs, 'Missing docker job'
assert 'deploy' in jobs, 'Missing deploy job'
# Check docker needs build-test
assert 'build-test' in jobs['docker'].get('needs', []) or jobs['docker'].get('needs') == 'build-test', 'docker must need build-test'
# Check deploy needs docker
assert 'docker' in jobs['deploy'].get('needs', []) or jobs['deploy'].get('needs') == 'docker', 'deploy must need docker'
# Check docker has version output
assert 'version' in str(jobs['docker'].get('outputs', {})), 'docker must output version'
# Check extract-version script is called
steps_str = str(jobs['docker'].get('steps', []))
assert 'extract-version.cjs' in steps_str, 'Must call extract-version.cjs'
assert 'BUILD_NUMBER' in steps_str, 'Must pass BUILD_NUMBER'
assert 'COMMIT_SHA' in steps_str, 'Must pass COMMIT_SHA'
# Check no commented out jobs remain
with open('.github/workflows/ci-deploy.yml') as f:
    content = f.read()
assert '# docker:' not in content, 'Old commented docker job still present'
assert '# deploy:' not in content, 'Old commented deploy job still present'
print('PASS: CI workflow structure valid')
" 2>&1</automated>
  </verify>
  <done>CI workflow has three active jobs: build-test (on all pushes/PRs), docker (build+push on main only using STATE.md-derived version tags), deploy (pull and restart on production server). No commented-out legacy code remains.</done>
</task>

</tasks>

<verification>
1. `Dockerfile` contains ARG BUILD_NUMBER, ARG COMMIT_SHA, runs extract-version.cjs before pnpm build
2. `.github/workflows/ci-deploy.yml` contains three jobs: build-test, docker, deploy
3. Docker job extracts version via `node scripts/extract-version.cjs` with BUILD_NUMBER and COMMIT_SHA
4. Docker images are tagged with version string (e.g., `1.0+42.abc1234`) and `latest`
5. Build-args pass BUILD_NUMBER, COMMIT_SHA, BUILD_DATE into Docker build
6. Deploy job SCPs config files and SSHs to restart services
7. No commented-out legacy job blocks remain in the workflow
</verification>

<success_criteria>
- CI workflow file has 3 active jobs with correct dependency chain: build-test -> docker -> deploy
- Docker job only runs on pushes to main (not PRs)
- Version is derived from STATE.md via extract-version script, not from commit history
- Dockerfile runs extract-version with build-args before compilation
- Build metadata (run number, SHA, date) is baked into the Docker image via version.ts
- Deploy step uses the same production paths and commands as the previous (commented) config
</success_criteria>

<output>
After completion, create `.planning/phases/16-ci-cd-pipeline/16-01-SUMMARY.md`
</output>
