---
phase: 12-app-deletion-backend
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/workers/snapshot.worker.ts
  - src/repositories/apps.ts
  - tests/workers/snapshot-worker-guard.test.ts
autonomous: true
requirements: [DEL-02]

must_haves:
  truths:
    - "A snapshot worker that detects its app has been deleted logs at info level and completes the job without writing to DB"
    - "The worker does not throw an error when the app is gone (no BullMQ retry loop)"
    - "The existence check happens before sending notifications and saving snapshot"
  artifacts:
    - path: "src/workers/snapshot.worker.ts"
      provides: "App-existence guard before commit phase"
      contains: "App deleted, aborting job"
    - path: "src/repositories/apps.ts"
      provides: "findAppById data access function"
      exports: ["findAppById"]
    - path: "tests/workers/snapshot-worker-guard.test.ts"
      provides: "Tests for worker app-existence guard"
      contains: "app deleted"
  key_links:
    - from: "src/workers/snapshot.worker.ts"
      to: "src/repositories/apps.ts"
      via: "findAppById() call before notifications"
      pattern: "findAppById\\("
    - from: "src/workers/snapshot.worker.ts"
      to: "return statement on app-deleted"
      via: "early return (clean completion)"
      pattern: "App deleted, aborting job"
---

<objective>
Add app-existence guard to the snapshot worker to handle in-flight jobs when an app is deleted.

Purpose: Implement DEL-02 — when a snapshot worker discovers its app has been deleted mid-processing, it logs and completes the job cleanly (no FK violations, no retry loop).

Output: Modified snapshot worker with existence check, new findAppById repository function, and tests.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-app-deletion-backend/12-CONTEXT.md
@.planning/phases/12-app-deletion-backend/12-RESEARCH.md

@src/workers/snapshot.worker.ts
@src/repositories/apps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add findAppById repository function and worker existence guard</name>
  <files>
    src/repositories/apps.ts
    src/workers/snapshot.worker.ts
  </files>
  <action>
**Repository function: `src/repositories/apps.ts`**

Add a new exported function `findAppById`:

```typescript
export async function findAppById(appId: string): Promise<{ app_id: string } | undefined> {
  const db = getDatabase();
  return db
    .selectFrom("apps")
    .select("app_id")
    .where("app_id", "=", appId)
    .executeTakeFirst();
}
```

This is a lightweight existence check (single column, no joins). Place it after the existing `createApp` function.

**Worker guard: `src/workers/snapshot.worker.ts`**

Add import for `findAppById` from `../repositories/apps.js`.

In `processSnapshotJob`, add an app-existence check **right before step 5 (sending notifications)**. This is after scanning/detecting changes but before any webhook calls or delivery recording. Per the RESEARCH.md recommendation: if the app is gone, there's no point sending webhooks to a URL that no longer cares, and this avoids recording deliveries or saving snapshots for a deleted app.

Insert between the change logging section (after "Log change summary" block) and the "Send notifications" section (step 5):

```typescript
// Check if app still exists before committing results
// (handles case where app was deleted while this job was processing)
const appStillExists = await findAppById(app_id);
if (!appStillExists) {
  console.log(`${logPrefix} App deleted, aborting job`);
  return; // Clean completion — no throw, no retry
}
```

This placement means:
- Git clone/pull has already happened (harmless — clone stays for other potential watchers)
- File scan has already happened (harmless — in-memory only)
- Change detection has already happened (harmless — in-memory only)
- But we SKIP: sending notifications, recording deliveries, saving snapshot, updating status
- The `return` makes BullMQ treat the job as completed (not failed), so no retry loop

IMPORTANT: The guard does NOT throw — it returns. This is per CONTEXT.md locked decision: "mark job as completed (not failed) so it doesn't retry".

The guard is inside the try block, so on return, the catch block is NOT triggered (no incrementRetryCount, no status update to pending_snapshot or failed).
  </action>
  <verify>
    <automated>pnpm typecheck</automated>
    <manual>Verify the existence check is placed before step 5 in the worker</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - `findAppById` function exists in apps.ts
    - Snapshot worker checks app existence before sending notifications
    - Guard uses return (not throw) for clean job completion
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for worker existence guard and findAppById</name>
  <files>
    tests/workers/snapshot-worker-guard.test.ts
  </files>
  <action>
Create a focused test file for the worker's app-existence guard behavior.

Mock dependencies:
- `../../src/db/index.js` (getDatabase)
- `../../src/repositories/apps.js` (findAppById)
- `../../src/services/git.js` (cloneOrPull, deleteLocalRepository)
- `../../src/services/repo-lock.js` (withRepoLock — execute callback immediately)
- `../../src/services/scanner.js` (scanRepository)
- `../../src/plugins/pipeline.js` (defaultPipeline)
- `../../src/services/notifier.js` (sendFileNotification, buildDeletePayload)
- `../../src/services/chunked-notifier.js` (sendFileWithChunking)
- `../../src/services/failure-notifier.js` (sendSyncFailedNotification)
- `../../src/repositories/snapshots.js` (saveSnapshot)
- `../../src/repositories/deliveries.js` (getDeliveredFiles, recordDelivery, removeDelivery)
- `../../src/repositories/repositories.js` (updateAppRepositoryStatus, incrementRetryCount, resetRetryCount, recordGitFailure, resetGitFailures)
- `../../src/utils/crypto.js` (decryptToken)
- `../../src/queue/connection.js` (getRedisUrl, getRedisOptions)
- `bullmq` (Worker)

The strategy: do NOT test processSnapshotJob directly (it's not exported). Instead, test through the Worker constructor. Mock `bullmq` Worker class to capture the processor callback, then invoke it with a mock Job.

Test cases:

1. **"should abort job cleanly when app is deleted during processing"**
   - Mock `findAppById` to return `undefined` (app deleted)
   - Mock cloneOrPull, scanRepository, getDeliveredFiles to succeed (earlier steps work)
   - Mock withRepoLock to execute callback
   - Mock decryptToken to return a dummy value
   - Create mock Job with valid SnapshotJobData
   - Invoke the captured processor callback
   - Assert: `sendFileWithChunking` was NOT called (no notifications sent)
   - Assert: `saveSnapshot` was NOT called (no snapshot saved)
   - Assert: `updateAppRepositoryStatus` was called with "scanning" (initial mark) but NOT called with "synced"
   - Assert: job completes without throwing (clean completion)
   - Assert: console.log was called with message containing "App deleted, aborting job"

2. **"should proceed normally when app still exists"**
   - Mock `findAppById` to return `{ app_id: 'test' }` (app exists)
   - Mock all other dependencies to succeed (including empty changes list for simplicity)
   - Assert: `saveSnapshot` WAS called
   - Assert: `updateAppRepositoryStatus` was called with "synced"

3. **"should not trigger retry when app is deleted"**
   - Mock `findAppById` to return `undefined`
   - Assert: `incrementRetryCount` was NOT called
   - Assert: no error was thrown

Follow the mock patterns from existing tests (e.g., `tests/services/repository-management.test.ts`). Use `vi.clearAllMocks()` in `beforeEach`.

Note: Create `tests/workers/` directory if it doesn't exist.
  </action>
  <verify>
    <automated>pnpm test</automated>
    <manual>All worker guard tests pass, no existing tests broken</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - Tests verify clean abort on app deletion (no notifications, no snapshot save, no retry)
    - Tests verify normal flow when app exists
    - Tests verify no retry triggered on app deletion
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm test` passes (all new + existing tests)
3. Worker contains app-existence check before notification phase
4. Guard returns (not throws) for clean BullMQ completion
5. findAppById is a lightweight single-column query
</verification>

<success_criteria>
- In-flight snapshot jobs that detect a deleted app complete cleanly without FK violations
- No retry loop triggered for deleted apps
- Worker skips notifications, delivery recording, and snapshot saving when app is gone
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-app-deletion-backend/12-02-SUMMARY.md`
</output>
