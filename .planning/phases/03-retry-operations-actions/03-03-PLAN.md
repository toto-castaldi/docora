---
phase: 03-retry-operations-actions
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/bulk-progress.ts
  - src/services/admin-actions.ts
  - src/routes/admin/dashboard-actions.ts
autonomous: true

must_haves:
  truths:
    - "POST /admin/api/retry/app/:appId returns 200 with operation_id and total count"
    - "POST /admin/api/retry/all returns 200 with operation_id and total count"
    - "GET /admin/api/retry/progress/:operationId returns live progress counters"
    - "POST /admin/api/retry/cancel/:operationId sets cancelled flag and stops remaining jobs"
    - "Progress counters update as individual retries complete"
    - "Cancelled flag is checked before processing each job in a batch"
  artifacts:
    - path: "src/services/bulk-progress.ts"
      provides: "Redis-based progress tracking with create, increment, cancel, get, cleanup"
      exports: ["createProgress", "incrementProgress", "cancelProgress", "getProgress", "markFailed"]
    - path: "src/services/admin-actions.ts"
      provides: "retryByApp and retryAll functions"
      exports: ["retrySingle", "retryByApp", "retryAll"]
    - path: "src/routes/admin/dashboard-actions.ts"
      provides: "Bulk retry endpoints + progress + cancel endpoints"
      contains: "admin/api/retry/app"
  key_links:
    - from: "src/services/admin-actions.ts"
      to: "src/services/bulk-progress.ts"
      via: "createProgress + incrementProgress for tracking"
      pattern: "createProgress|incrementProgress"
    - from: "src/routes/admin/dashboard-actions.ts"
      to: "src/services/admin-actions.ts"
      via: "retryByApp and retryAll calls"
      pattern: "retryByApp|retryAll"
    - from: "src/services/bulk-progress.ts"
      to: "ioredis"
      via: "Redis hash for progress tracking"
      pattern: "redis\\.hset|redis\\.hincrby"
---

<objective>
Build the bulk retry backend: a Redis-based progress tracking service, bulk retry functions (per-app and global), and all remaining action endpoints including progress polling and cancellation.

Purpose: Enables admin to retry all failed notifications at once with live progress tracking and the ability to cancel mid-operation.
Output: Working bulk retry endpoints with Redis-based progress tracking and cancellation support.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-retry-operations-actions/03-01-SUMMARY.md
@src/services/admin-actions.ts
@src/routes/admin/dashboard-actions.ts
@src/services/queue-status.ts
@src/queue/connection.ts
@src/repositories/admin-dashboard.ts
@src/repositories/repositories.ts
@src/workers/snapshot.scheduler.ts
@packages/shared-types/src/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis-based bulk progress tracking service</name>
  <files>
    src/services/bulk-progress.ts
  </files>
  <action>
    Create `src/services/bulk-progress.ts` -- a small service for tracking bulk operation progress via Redis hashes.

    **Redis key pattern:** `docora:bulk:{operationId}` with TTL of 1 hour (3600s) to prevent key leaks.

    **Functions to implement:**

    1. `generateOperationId(): string` -- returns `bulk_${randomBytes(8).toString("hex")}`

    2. `createProgress(operationId: string, total: number): Promise<void>`
       - Use `getRedisConnection()` from `../queue/connection.js`
       - `redis.hset(key, { total, completed: 0, succeeded: 0, failed: 0, cancelled: "false" })`
       - `redis.expire(key, 3600)` -- 1 hour TTL

    3. `incrementProgress(operationId: string, success: boolean): Promise<void>`
       - Pipeline: `hincrby(key, "completed", 1)` + `hincrby(key, success ? "succeeded" : "failed", 1)`
       - Use Redis pipeline for atomicity

    4. `cancelProgress(operationId: string): Promise<void>`
       - `redis.hset(key, "cancelled", "true")`

    5. `isCancelled(operationId: string): Promise<boolean>`
       - `redis.hget(key, "cancelled")` returns "true" or "false"

    6. `getProgress(operationId: string): Promise<BulkProgressResponse | null>`
       - `redis.hgetall(key)` -- returns all fields
       - If empty (key expired), return null
       - Parse string values to numbers, cancelled to boolean
       - Return typed `BulkProgressResponse` object

    Import `getRedisConnection` from `../queue/connection.js`, `randomBytes` from `crypto`.
    Import `BulkProgressResponse` from `@docora/shared-types`.

    Keep under 100 lines. Use the KEY_PREFIX constant `docora:bulk:`.
  </action>
  <verify>
    Run `cd /home/toto/scm-projects/docora && pnpm typecheck` -- no type errors.
  </verify>
  <done>
    bulk-progress.ts exports all 6 functions. Uses Redis hashes with TTL for progress tracking. Cancellation is a simple flag check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bulk retry service functions and endpoints</name>
  <files>
    src/services/admin-actions.ts
    src/routes/admin/dashboard-actions.ts
  </files>
  <action>
    **Extend admin-actions.ts with two new functions:**

    1. `retryByApp(appId: string): Promise<{ operationId: string; total: number }>`
       - Query all app_repositories WHERE app_id = appId AND status = 'failed'
       - If none found, throw Error("No failed notifications for this app")
       - Call `createProgress(operationId, total)` from bulk-progress
       - For each failed entry, process sequentially:
         a. Check `isCancelled(operationId)` -- if true, break loop
         b. Try: reset status to pending_snapshot, reset retry_count=0, clear last_error, queue BullMQ job (same as retrySingle but without status validation), call `incrementProgress(operationId, true)`
         c. Catch: call `incrementProgress(operationId, false)` (mark as failed but continue)
       - Return { operationId, total }
       - IMPORTANT: Do NOT await all jobs -- process them in a fire-and-forget async IIFE so the endpoint returns immediately with the operation_id. The processing continues in the background.

    2. `retryAll(): Promise<{ operationId: string; total: number }>`
       - Query all app_repositories WHERE status = 'failed' (across all apps)
       - Same pattern as retryByApp but no app filter
       - Same fire-and-forget background processing

    **Helper refactor:** Extract the common "reset + queue" logic from retrySingle into a private helper `resetAndQueue(appId, repositoryId, jobData)` that both retrySingle and the bulk functions use. This avoids duplicating the DB update + queue logic.

    **Add endpoints to dashboard-actions.ts:**

    1. `POST /admin/api/retry/app/:appId` -- calls retryByApp, returns `{ data: { message, operation_id, total } }`
    2. `POST /admin/api/retry/all` -- calls retryAll, returns same shape
    3. `GET /admin/api/retry/progress/:operationId` -- calls getProgress, returns 200 with progress data or 404 if expired
    4. `POST /admin/api/retry/cancel/:operationId` -- calls cancelProgress, returns 200 with `{ data: { message: "Cancellation requested" } }`

    Error handling: 404 for "no failed notifications", 500 for unexpected errors. All endpoints require session auth (already covered by the onRequest hook).

    NOTE: The file may exceed 150 lines with all endpoints. If so, split: keep single retry in dashboard-actions.ts and create a new `src/routes/admin/dashboard-bulk-actions.ts` for bulk endpoints. Register it in admin/index.ts.
  </action>
  <verify>
    Run `cd /home/toto/scm-projects/docora && pnpm typecheck && pnpm build` -- both pass.
  </verify>
  <done>
    - retryByApp and retryAll functions in admin-actions.ts with background processing
    - All 4 bulk endpoints registered and type-safe
    - Progress tracking wired through bulk-progress service
    - Cancellation endpoint sets flag that background loop checks
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm build` succeeds
- bulk-progress.ts exports: createProgress, incrementProgress, cancelProgress, isCancelled, getProgress, generateOperationId
- admin-actions.ts exports: retrySingle, retryByApp, retryAll
- All endpoints accessible under /admin/api/retry/*
- Background processing uses fire-and-forget pattern (endpoint returns immediately)
</verification>

<success_criteria>
- Bulk retry endpoints return operation_id immediately without waiting for all retries
- Redis progress hash created with correct fields and TTL
- Each retry in the batch increments progress counters
- Cancellation flag stops remaining retries in the batch
- Progress endpoint returns live counters
</success_criteria>

<output>
After completion, create `.planning/phases/03-retry-operations-actions/03-03-SUMMARY.md`
</output>
