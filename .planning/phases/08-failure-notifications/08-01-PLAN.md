---
phase: 08-failure-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/notifier.ts
  - src/services/failure-notifier.ts
  - src/repositories/repositories.ts
  - src/workers/snapshot.worker.ts
autonomous: true

must_haves:
  truths:
    - "When a circuit breaker opens for a repository, ALL apps watching that repository receive a sync_failed webhook POST"
    - "The sync_failed payload includes error type, error message, retry count, and circuit breaker status"
    - "The sync_failed webhook is signed with the same HMAC mechanism used for file change notifications"
    - "Existing file change notifications (create/update/delete) continue to work without regression"
  artifacts:
    - path: "src/services/failure-notifier.ts"
      provides: "sync_failed notification sending logic"
      exports: ["sendSyncFailedNotification", "SyncFailedPayload"]
    - path: "src/services/notifier.ts"
      provides: "Updated NotificationEndpoint type including sync_failed"
      contains: "sync_failed"
    - path: "src/repositories/repositories.ts"
      provides: "Query to find all apps watching a repository"
      exports: ["findAppsWatchingRepository"]
  key_links:
    - from: "src/workers/snapshot.worker.ts"
      to: "src/services/failure-notifier.ts"
      via: "import and call when circuitOpened is true"
      pattern: "sendSyncFailedNotification"
    - from: "src/services/failure-notifier.ts"
      to: "src/repositories/repositories.ts"
      via: "import findAppsWatchingRepository to get all watching apps"
      pattern: "findAppsWatchingRepository"
    - from: "src/services/failure-notifier.ts"
      to: "src/utils/signature.ts"
      via: "import generateSignedHeaders for HMAC signing"
      pattern: "generateSignedHeaders"
---

<objective>
Implement sync_failed webhook notifications when the circuit breaker opens for a repository.

Purpose: Apps need to know proactively when Docora cannot sync their watched repositories, so they can take action (e.g., rotate tokens, check repo access) instead of silently receiving no updates.

Output: A complete notification pipeline — data access query to find watching apps, a failure-notifier service that builds and sends signed sync_failed webhooks, and wiring in the snapshot worker to trigger notifications when the circuit breaker opens.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/notifier.ts
@src/services/chunked-notifier.ts
@src/utils/signature.ts
@src/repositories/repositories.ts
@src/workers/snapshot.worker.ts
@src/db/types/repositories.ts
@src/db/types/apps.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create failure-notifier service and data access query</name>
  <files>
    src/services/notifier.ts
    src/services/failure-notifier.ts
    src/repositories/repositories.ts
  </files>
  <action>
**1. Update `src/services/notifier.ts`:**

Add `"sync_failed"` to the `NotificationEndpoint` type union:
```typescript
export type NotificationEndpoint = "create" | "update" | "delete" | "sync_failed";
```
This is the ONLY change to notifier.ts. No other modifications.

**2. Add `findAppsWatchingRepository` to `src/repositories/repositories.ts`:**

Add a new exported async function at the end of the file that queries all apps linked to a given repository:
```typescript
export async function findAppsWatchingRepository(repositoryId: string): Promise<Array<{
  app_id: string;
  app_name: string;
  base_url: string;
  client_auth_key_encrypted: string;
}>>
```
Implementation: `SELECT ar.app_id, a.app_name, a.base_url, a.client_auth_key_encrypted FROM app_repositories ar JOIN apps a ON a.app_id = ar.app_id WHERE ar.repository_id = $1`.

Use Kysely: `db.selectFrom("app_repositories").innerJoin("apps", "apps.app_id", "app_repositories.app_id").select([...]).where("app_repositories.repository_id", "=", repositoryId).execute()`.

NOTE: repositories.ts is already 564 lines (above the 150-line convention). This is an existing large file; adding one small function (~15 lines) is acceptable since splitting repositories.ts is a separate refactoring concern. Add it at the end, before or after `deleteRepository`.

**3. Create `src/services/failure-notifier.ts`:**

This is a NEW file. It handles sending sync_failed notifications to all apps watching a repository when the circuit breaker opens.

Define the `SyncFailedPayload` interface:
```typescript
export interface SyncFailedPayload {
  event: "sync_failed";
  repository: {
    repository_id: string;
    github_url: string;
    owner: string;
    name: string;
  };
  error: {
    type: string;       // "git_failure" (for now, extensible later)
    message: string;    // The actual error message from git
  };
  circuit_breaker: {
    status: "open";
    consecutive_failures: number;
    threshold: number;
    cooldown_until: string; // ISO 8601 timestamp
  };
  retry_count: number;  // From app_repositories.retry_count for this app
  timestamp: string;    // ISO 8601
}
```

Define params interface:
```typescript
export interface SyncFailedParams {
  repositoryId: string;
  githubUrl: string;
  owner: string;
  name: string;
  errorMessage: string;
  consecutiveFailures: number;
  threshold: number;
  cooldownUntil: Date;
}
```

Export `sendSyncFailedNotification(params: SyncFailedParams): Promise<void>`:
1. Call `findAppsWatchingRepository(params.repositoryId)` to get all watching apps
2. For each app:
   a. Decrypt `client_auth_key_encrypted` using `decryptToken` from `src/utils/crypto.js`
   b. Build `SyncFailedPayload` with the params (set retry_count to 0 for now — we don't have per-app retry_count in this context, so use the consecutive_failures from the repo)
   c. Actually, we DO need per-app retry_count. Update `findAppsWatchingRepository` to also select `app_repositories.retry_count` and return it. Add `retry_count: number` to the return type.
   d. Call `generateSignedHeaders(app.app_id, payload, clientAuthKey)` from `src/utils/signature.js`
   e. POST to `${app.base_url}/sync_failed` using axios with the signed headers
   f. Log success/failure per app (fire-and-forget pattern: log errors but do NOT throw, since this is a best-effort notification that should not block the worker)
3. Use a for-of loop (sequential, not parallel) to avoid overwhelming client endpoints
4. Import axios from "axios" (already a project dependency)

Keep this file well under 150 lines. The file should have:
- Type exports (SyncFailedPayload, SyncFailedParams)
- One main exported function (sendSyncFailedNotification)
- Clear imports from notifier (for RepositoryInfo type reuse if helpful), signature, crypto, and repositories

The function should NOT throw errors — it's fire-and-forget. All errors are caught and logged. The circuit breaker opening should not be blocked by notification delivery failures.
  </action>
  <verify>
Run `pnpm typecheck` — must pass with no errors. Verify:
- NotificationEndpoint type includes "sync_failed"
- failure-notifier.ts exports SyncFailedPayload and sendSyncFailedNotification
- findAppsWatchingRepository is exported from repositories.ts
  </verify>
  <done>
- `src/services/failure-notifier.ts` exists with `sendSyncFailedNotification` that queries all watching apps, builds a signed sync_failed payload, and POSTs to each app's base_url/sync_failed endpoint
- `findAppsWatchingRepository` exists in repositories.ts and returns app_id, app_name, base_url, client_auth_key_encrypted, retry_count
- NotificationEndpoint type includes "sync_failed"
- `pnpm typecheck` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire failure-notifier into snapshot worker on circuit breaker open</name>
  <files>
    src/workers/snapshot.worker.ts
  </files>
  <action>
**Modify `src/workers/snapshot.worker.ts`:**

In the git error catch block (around lines 181-199), after calling `recordGitFailure` and checking `circuitOpened`:

1. Add import at top of file:
```typescript
import { sendSyncFailedNotification } from "../services/failure-notifier.js";
```

2. After the existing `console.error` log at line 197, add a conditional block:
```typescript
if (circuitOpened) {
  // Notify all apps watching this repository (fire-and-forget)
  const CIRCUIT_BREAKER_THRESHOLD = parseInt(process.env.CIRCUIT_BREAKER_THRESHOLD || "5", 10);
  const CIRCUIT_BREAKER_COOLDOWN_MS = parseInt(process.env.CIRCUIT_BREAKER_COOLDOWN_MS || "1800000", 10);

  sendSyncFailedNotification({
    repositoryId: repository_id,
    githubUrl: github_url,
    owner,
    name,
    errorMessage: (gitError as Error).message ?? String(gitError),
    consecutiveFailures: consecutiveFailures,
    threshold: CIRCUIT_BREAKER_THRESHOLD,
    cooldownUntil: new Date(Date.now() + CIRCUIT_BREAKER_COOLDOWN_MS),
  }).catch((err) => {
    console.error(`${logPrefix} Failed to send sync_failed notifications:`, (err as Error).message);
  });
}
```

IMPORTANT details:
- Use `.catch()` on the promise (fire-and-forget). Do NOT await it. The worker should re-throw `gitError` immediately without waiting for notifications to complete.
- The `CIRCUIT_BREAKER_THRESHOLD` and `CIRCUIT_BREAKER_COOLDOWN_MS` constants are already defined in `repositories.ts` but NOT exported. Rather than importing them (which would couple worker to repository internals), read them from env vars directly in the worker (same pattern as repositories.ts uses). This is a conscious trade-off: slight duplication vs unnecessary coupling.
- The `throw gitError` line must remain AFTER this block, so the BullMQ retry mechanism is not disrupted.
- The cooldownUntil is calculated here (same formula as recordGitFailure) because the notification needs to know when the circuit will close. This is the same `new Date(Date.now() + CIRCUIT_BREAKER_COOLDOWN_MS)` formula used in `recordGitFailure`.

The modified catch block structure should be:
```
} catch (gitError) {
  // ... existing auth error detection and logging ...
  const { circuitOpened, consecutiveFailures } = await recordGitFailure(repository_id);
  console.error(`${logPrefix} Git failures: ...`);

  if (circuitOpened) {
    // NEW: fire-and-forget sync_failed notification
    sendSyncFailedNotification({ ... }).catch(...);
  }

  throw gitError;  // existing line, unchanged
}
```
  </action>
  <verify>
Run `pnpm typecheck` — must pass. Run `pnpm build` — must compile without errors. Verify that:
1. The import of sendSyncFailedNotification is present
2. The circuitOpened check triggers the notification
3. The `throw gitError` line is still present after the notification block
4. The notification is fire-and-forget (no await, has .catch())
  </verify>
  <done>
- Snapshot worker sends sync_failed notifications to all watching apps when circuit breaker opens
- Notification is fire-and-forget (does not block worker or disrupt BullMQ retry)
- Existing file notification flow (create/update/delete) is completely unchanged
- `pnpm build` succeeds
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes — all types are correct
2. `pnpm build` succeeds — project compiles
3. Code review: `src/services/failure-notifier.ts` exists and exports `sendSyncFailedNotification` and `SyncFailedPayload`
4. Code review: `src/workers/snapshot.worker.ts` calls `sendSyncFailedNotification` only when `circuitOpened === true`
5. Code review: The notification uses `generateSignedHeaders` from `src/utils/signature.ts` (same HMAC mechanism)
6. Code review: `findAppsWatchingRepository` in `src/repositories/repositories.ts` queries ALL apps for a given repository_id
7. Code review: The `throw gitError` line in snapshot.worker.ts is preserved (BullMQ retry not disrupted)
8. Code review: Notification is fire-and-forget (`.catch()`, no `await`)
</verification>

<success_criteria>
- sync_failed notification service created with HMAC-signed webhooks
- All apps watching a repository are notified when circuit breaker opens
- Payload includes: error type, error message, consecutive_failures, threshold, cooldown_until, retry_count
- Fire-and-forget pattern: notification errors logged but do not block worker
- Existing create/update/delete notifications completely unchanged
- Project compiles and type-checks successfully
</success_criteria>

<output>
After completion, create `.planning/phases/08-failure-notifications/08-01-SUMMARY.md`
</output>
