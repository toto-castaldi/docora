---
phase: 02-dashboard-core-display
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/queue-status.ts
  - src/routes/admin/dashboard-api.ts
  - src/repositories/admin-dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Admin can fetch job queue status with counts"
    - "Admin can fetch list of waiting and active jobs"
    - "Admin can fetch failed notifications with error details"
    - "Admin can fetch overview metrics"
  artifacts:
    - path: "src/services/queue-status.ts"
      provides: "BullMQ queue status access"
      exports: ["getQueueStatus", "getQueueJobs"]
    - path: "src/routes/admin/dashboard-api.ts"
      provides: "Queue and notifications API routes"
      contains: "/api/queue"
  key_links:
    - from: "src/routes/admin/dashboard-api.ts"
      to: "src/services/queue-status.ts"
      via: "import and function calls"
      pattern: "getQueueStatus|getQueueJobs"
---

<objective>
Create backend API endpoints for queue status, failed notifications, and overview metrics.

Purpose: Provide data for the Queue, Notifications, and Overview frontend pages.
Output: GET /admin/api/queue, GET /admin/api/notifications/failed, GET /admin/api/overview endpoints.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dashboard-core-display/02-RESEARCH.md
@src/queue/connection.ts
@src/workers/snapshot.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create queue status service</name>
  <files>src/services/queue-status.ts</files>
  <action>
Create `src/services/queue-status.ts` to wrap BullMQ queue methods:

```typescript
import { Queue } from "bullmq";
import { getRedisUrl, getRedisOptions } from "../queue/connection.js";
import { SNAPSHOT_QUEUE_NAME, type SnapshotJobData } from "../workers/snapshot.worker.js";

export interface QueueCounts {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
}

export interface QueueJobInfo {
  id: string;
  name: string;
  app_name: string;
  repository_name: string;
  status: "waiting" | "active" | "delayed";
  created_at: string;
  processed_on: string | null;
}

let queue: Queue<SnapshotJobData> | null = null;

function getQueue(): Queue<SnapshotJobData> {
  if (!queue) {
    queue = new Queue<SnapshotJobData>(SNAPSHOT_QUEUE_NAME, {
      connection: {
        url: getRedisUrl(),
        ...getRedisOptions(),
      },
    });
  }
  return queue;
}

/**
 * Get queue job counts by status
 */
export async function getQueueStatus(): Promise<QueueCounts> {
  const q = getQueue();
  const counts = await q.getJobCounts(
    "waiting",
    "active",
    "completed",
    "failed",
    "delayed"
  );
  return {
    waiting: counts.waiting || 0,
    active: counts.active || 0,
    completed: counts.completed || 0,
    failed: counts.failed || 0,
    delayed: counts.delayed || 0,
  };
}

/**
 * Get list of waiting and active jobs
 */
export async function getQueueJobs(limit: number = 50): Promise<QueueJobInfo[]> {
  const q = getQueue();

  const [waitingJobs, activeJobs, delayedJobs] = await Promise.all([
    q.getWaiting(0, limit),
    q.getActive(0, limit),
    q.getDelayed(0, limit),
  ]);

  const mapJob = (
    job: Awaited<ReturnType<typeof q.getWaiting>>[number],
    status: QueueJobInfo["status"]
  ): QueueJobInfo => ({
    id: job.id ?? "unknown",
    name: job.name,
    app_name: job.data.app_name,
    repository_name: `${job.data.owner}/${job.data.name}`,
    status,
    created_at: new Date(job.timestamp).toISOString(),
    processed_on: job.processedOn
      ? new Date(job.processedOn).toISOString()
      : null,
  });

  return [
    ...activeJobs.map((j) => mapJob(j, "active")),
    ...waitingJobs.map((j) => mapJob(j, "waiting")),
    ...delayedJobs.map((j) => mapJob(j, "delayed")),
  ];
}

/**
 * Clean up queue connection
 */
export async function closeQueueConnection(): Promise<void> {
  if (queue) {
    await queue.close();
    queue = null;
  }
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify types compile</verify>
  <done>Queue status service created with getQueueStatus and getQueueJobs functions</done>
</task>

<task type="auto">
  <name>Task 2: Add failed notifications and overview to repository layer</name>
  <files>src/repositories/admin-dashboard.ts</files>
  <action>
Add these functions to `src/repositories/admin-dashboard.ts`:

```typescript
export interface FailedNotificationResult {
  app_id: string;
  app_name: string;
  repository_id: string;
  repository_name: string;
  github_url: string;
  error_message: string;
  retry_count: number;
  last_scanned_at: Date | null;
}

/**
 * List failed notifications (app_repositories with status = 'failed')
 */
export async function listFailedNotifications(): Promise<FailedNotificationResult[]> {
  const db = getDatabase();

  const results = await db
    .selectFrom("app_repositories")
    .innerJoin(
      "repositories",
      "repositories.repository_id",
      "app_repositories.repository_id"
    )
    .innerJoin("apps", "apps.app_id", "app_repositories.app_id")
    .select([
      "apps.app_id",
      "apps.app_name",
      "repositories.repository_id",
      "repositories.owner",
      "repositories.name",
      "repositories.github_url",
      "app_repositories.last_error",
      "app_repositories.retry_count",
      "app_repositories.last_scanned_at",
    ])
    .where("app_repositories.status", "=", "failed")
    .orderBy("app_repositories.last_scanned_at", "desc")
    .execute();

  return results.map((r) => ({
    app_id: r.app_id,
    app_name: r.app_name,
    repository_id: r.repository_id,
    repository_name: `${r.owner}/${r.name}`,
    github_url: r.github_url,
    error_message: r.last_error ?? "Unknown error",
    retry_count: r.retry_count ?? 0,
    last_scanned_at: r.last_scanned_at,
  }));
}

/**
 * Get overview counts for dashboard
 */
export async function getOverviewCounts(): Promise<{
  total_apps: number;
  total_repositories: number;
  failed_notifications: number;
}> {
  const db = getDatabase();

  const [appsResult, reposResult, failedResult] = await Promise.all([
    db
      .selectFrom("apps")
      .select((eb) => eb.fn.count("app_id").as("count"))
      .executeTakeFirst(),
    db
      .selectFrom("app_repositories")
      .select((eb) => eb.fn.count("id").as("count"))
      .executeTakeFirst(),
    db
      .selectFrom("app_repositories")
      .select((eb) => eb.fn.count("id").as("count"))
      .where("status", "=", "failed")
      .executeTakeFirst(),
  ]);

  return {
    total_apps: Number(appsResult?.count) || 0,
    total_repositories: Number(reposResult?.count) || 0,
    failed_notifications: Number(failedResult?.count) || 0,
  };
}
```

Add these exports to the imports at the top of the file if not already present.
  </action>
  <verify>Run `pnpm typecheck` to verify types compile</verify>
  <done>Failed notifications and overview count functions added to admin-dashboard repository</done>
</task>

<task type="auto">
  <name>Task 3: Add queue, notifications, and overview API routes</name>
  <files>src/routes/admin/dashboard-api.ts</files>
  <action>
Add these routes to `src/routes/admin/dashboard-api.ts`:

1. Add imports at the top:
```typescript
import { getQueueStatus, getQueueJobs } from "../../services/queue-status.js";
import {
  listAppsWithCounts,
  getAppById,
  listRepositoriesByApp,
  listAllRepositories,
  listFailedNotifications,
  getOverviewCounts,
} from "../../repositories/admin-dashboard.js";
import type {
  AppSummary,
  AppDetail,
  RepositorySummary,
  QueueStatus,
  QueueJob,
  FailedNotification,
  OverviewMetrics,
  ApiResponse,
  ApiErrorResponse,
} from "@docora/shared-types";
```

2. Add these route handlers inside the `dashboardApiRoutes` function:

```typescript
  // GET /admin/api/queue - Get queue status and jobs
  server.get<{
    Reply: ApiResponse<{ status: QueueStatus; jobs: QueueJob[] }> | ApiErrorResponse;
  }>("/api/queue", async (_request, reply) => {
    try {
      const [status, jobs] = await Promise.all([
        getQueueStatus(),
        getQueueJobs(50),
      ]);

      return reply.send({
        data: {
          status: {
            waiting: status.waiting,
            active: status.active,
            completed: status.completed,
            failed: status.failed,
            delayed: status.delayed,
          },
          jobs: jobs.map((job) => ({
            id: job.id,
            name: job.name,
            app_name: job.app_name,
            repository_name: job.repository_name,
            status: job.status,
            created_at: job.created_at,
            processed_on: job.processed_on,
          })),
        },
      });
    } catch (error) {
      console.error("Error fetching queue status:", error);
      return reply.code(500).send({ error: "Failed to fetch queue status" });
    }
  });

  // GET /admin/api/notifications/failed - List failed notifications
  server.get<{ Reply: ApiResponse<FailedNotification[]> | ApiErrorResponse }>(
    "/api/notifications/failed",
    async (_request, reply) => {
      try {
        const notifications = await listFailedNotifications();
        const response: FailedNotification[] = notifications.map((n) => ({
          app_id: n.app_id,
          app_name: n.app_name,
          repository_id: n.repository_id,
          repository_name: n.repository_name,
          github_url: n.github_url,
          error_message: n.error_message,
          timestamp: n.last_scanned_at?.toISOString() ?? new Date().toISOString(),
          retry_count: n.retry_count,
        }));
        return reply.send({ data: response });
      } catch (error) {
        console.error("Error fetching failed notifications:", error);
        return reply.code(500).send({ error: "Failed to fetch notifications" });
      }
    }
  );

  // GET /admin/api/overview - Get overview metrics
  server.get<{ Reply: ApiResponse<OverviewMetrics> | ApiErrorResponse }>(
    "/api/overview",
    async (_request, reply) => {
      try {
        const [counts, queueStatus] = await Promise.all([
          getOverviewCounts(),
          getQueueStatus(),
        ]);

        const response: OverviewMetrics = {
          total_apps: counts.total_apps,
          total_repositories: counts.total_repositories,
          failed_notifications: counts.failed_notifications,
          queue_waiting: queueStatus.waiting,
          queue_active: queueStatus.active,
        };

        return reply.send({ data: response });
      } catch (error) {
        console.error("Error fetching overview:", error);
        return reply.code(500).send({ error: "Failed to fetch overview" });
      }
    }
  );
```
  </action>
  <verify>
1. Run `pnpm typecheck` to verify types
2. Run `pnpm build` to ensure compilation succeeds
  </verify>
  <done>Queue, notifications, and overview API routes added with session auth protection</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm build` succeeds
3. All new endpoints are registered under /admin/api/
4. All endpoints require session authentication
</verification>

<success_criteria>
- GET /admin/api/queue returns queue status counts and list of jobs
- GET /admin/api/notifications/failed returns failed notifications with error details
- GET /admin/api/overview returns overview metrics (app count, repo count, failures, queue)
- All endpoints return 401 for unauthenticated requests
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-dashboard-core-display/02-03-SUMMARY.md`
</output>
