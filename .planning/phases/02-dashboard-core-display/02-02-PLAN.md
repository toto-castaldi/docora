---
phase: 02-dashboard-core-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routes/admin/dashboard-api.ts
  - src/routes/admin/index.ts
  - src/repositories/admin-dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Admin can fetch list of apps with repository and failure counts"
    - "Admin can fetch app detail with linked repositories"
    - "Admin can fetch list of all repositories with status"
  artifacts:
    - path: "src/routes/admin/dashboard-api.ts"
      provides: "Dashboard API routes"
      exports: ["dashboardApiRoutes"]
    - path: "src/repositories/admin-dashboard.ts"
      provides: "Dashboard data access layer"
      exports: ["listAppsWithCounts", "getAppDetail", "listAllRepositories"]
  key_links:
    - from: "src/routes/admin/dashboard-api.ts"
      to: "src/repositories/admin-dashboard.ts"
      via: "import and function calls"
      pattern: "listAppsWithCounts|getAppDetail|listAllRepositories"
---

<objective>
Create backend API endpoints for apps and repositories dashboard data.

Purpose: Provide data for the Apps, Repositories, and AppDetail frontend pages.
Output: GET /admin/api/apps, GET /admin/api/apps/:id, GET /admin/api/repositories endpoints with session auth.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dashboard-core-display/02-RESEARCH.md
@src/routes/admin/index.ts
@src/routes/admin/auth.ts
@src/db/types/index.ts
@src/repositories/apps.ts
@src/repositories/repositories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin dashboard repository layer</name>
  <files>src/repositories/admin-dashboard.ts</files>
  <action>
Create `src/repositories/admin-dashboard.ts` with data access functions for dashboard:

```typescript
import { getDatabase } from "../db/index.js";
import { sql } from "kysely";

export interface AppWithCounts {
  app_id: string;
  app_name: string;
  base_url: string;
  created_at: Date;
  repository_count: number;
  failed_notification_count: number;
}

export interface AppDetailResult {
  app_id: string;
  app_name: string;
  base_url: string;
  email: string;
  website: string | null;
  description: string | null;
  created_at: Date;
}

export interface RepositoryWithStatus {
  repository_id: string;
  github_url: string;
  owner: string;
  name: string;
  status: string;
  last_scanned_at: Date | null;
  circuit_open: boolean;
  app_id: string;
  app_name: string;
}

/**
 * List all apps with repository and failure counts
 */
export async function listAppsWithCounts(): Promise<AppWithCounts[]> {
  const db = getDatabase();

  const results = await db
    .selectFrom("apps")
    .leftJoin("app_repositories", "apps.app_id", "app_repositories.app_id")
    .select([
      "apps.app_id",
      "apps.app_name",
      "apps.base_url",
      "apps.created_at",
    ])
    .select((eb) => [
      eb.fn.count("app_repositories.repository_id").as("repository_count"),
      eb.fn
        .sum(
          eb
            .case()
            .when("app_repositories.status", "=", "failed")
            .then(1)
            .else(0)
            .end()
        )
        .as("failed_notification_count"),
    ])
    .groupBy([
      "apps.app_id",
      "apps.app_name",
      "apps.base_url",
      "apps.created_at",
    ])
    .orderBy("apps.created_at", "desc")
    .execute();

  return results.map((r) => ({
    app_id: r.app_id,
    app_name: r.app_name,
    base_url: r.base_url,
    created_at: r.created_at,
    repository_count: Number(r.repository_count) || 0,
    failed_notification_count: Number(r.failed_notification_count) || 0,
  }));
}

/**
 * Get app detail by ID
 */
export async function getAppById(appId: string): Promise<AppDetailResult | null> {
  const db = getDatabase();

  const result = await db
    .selectFrom("apps")
    .select([
      "app_id",
      "app_name",
      "base_url",
      "email",
      "website",
      "description",
      "created_at",
    ])
    .where("app_id", "=", appId)
    .executeTakeFirst();

  return result ?? null;
}

/**
 * List repositories for a specific app with status
 */
export async function listRepositoriesByApp(appId: string): Promise<RepositoryWithStatus[]> {
  const db = getDatabase();

  const results = await db
    .selectFrom("app_repositories")
    .innerJoin(
      "repositories",
      "repositories.repository_id",
      "app_repositories.repository_id"
    )
    .innerJoin("apps", "apps.app_id", "app_repositories.app_id")
    .select([
      "repositories.repository_id",
      "repositories.github_url",
      "repositories.owner",
      "repositories.name",
      "repositories.circuit_open_until",
      "app_repositories.status",
      "app_repositories.last_scanned_at",
      "apps.app_id",
      "apps.app_name",
    ])
    .where("app_repositories.app_id", "=", appId)
    .orderBy("repositories.created_at", "desc")
    .execute();

  const now = new Date();
  return results.map((r) => ({
    repository_id: r.repository_id,
    github_url: r.github_url,
    owner: r.owner,
    name: r.name,
    status: r.status,
    last_scanned_at: r.last_scanned_at,
    circuit_open: r.circuit_open_until ? r.circuit_open_until > now : false,
    app_id: r.app_id,
    app_name: r.app_name,
  }));
}

/**
 * List all repositories across all apps with status
 */
export async function listAllRepositories(): Promise<RepositoryWithStatus[]> {
  const db = getDatabase();

  const results = await db
    .selectFrom("app_repositories")
    .innerJoin(
      "repositories",
      "repositories.repository_id",
      "app_repositories.repository_id"
    )
    .innerJoin("apps", "apps.app_id", "app_repositories.app_id")
    .select([
      "repositories.repository_id",
      "repositories.github_url",
      "repositories.owner",
      "repositories.name",
      "repositories.circuit_open_until",
      "app_repositories.status",
      "app_repositories.last_scanned_at",
      "apps.app_id",
      "apps.app_name",
    ])
    .orderBy("repositories.created_at", "desc")
    .execute();

  const now = new Date();
  return results.map((r) => ({
    repository_id: r.repository_id,
    github_url: r.github_url,
    owner: r.owner,
    name: r.name,
    status: r.status,
    last_scanned_at: r.last_scanned_at,
    circuit_open: r.circuit_open_until ? r.circuit_open_until > now : false,
    app_id: r.app_id,
    app_name: r.app_name,
  }));
}
```
  </action>
  <verify>Run `pnpm typecheck` to verify types compile correctly</verify>
  <done>Admin dashboard repository layer created with listAppsWithCounts, getAppById, listRepositoriesByApp, listAllRepositories</done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard API routes and register them</name>
  <files>src/routes/admin/dashboard-api.ts, src/routes/admin/index.ts</files>
  <action>
1. Create `src/routes/admin/dashboard-api.ts`:

```typescript
import type { FastifyInstance } from "fastify";
import {
  listAppsWithCounts,
  getAppById,
  listRepositoriesByApp,
  listAllRepositories,
} from "../../repositories/admin-dashboard.js";
import type {
  AppSummary,
  AppDetail,
  RepositorySummary,
  ApiResponse,
  ApiErrorResponse,
} from "@docora/shared-types";

export async function dashboardApiRoutes(server: FastifyInstance): Promise<void> {
  // Require session auth for all dashboard API routes
  server.addHook("onRequest", async (request, reply) => {
    if (!request.session?.get("adminId")) {
      reply.code(401).send({ error: "Unauthorized" } satisfies ApiErrorResponse);
    }
  });

  // GET /admin/api/apps - List all apps with counts
  server.get<{ Reply: ApiResponse<AppSummary[]> | ApiErrorResponse }>(
    "/api/apps",
    async (_request, reply) => {
      try {
        const apps = await listAppsWithCounts();
        const response: AppSummary[] = apps.map((app) => ({
          app_id: app.app_id,
          app_name: app.app_name,
          base_url: app.base_url,
          created_at: app.created_at.toISOString(),
          repository_count: app.repository_count,
          failed_notification_count: app.failed_notification_count,
        }));
        return reply.send({ data: response });
      } catch (error) {
        console.error("Error fetching apps:", error);
        return reply.code(500).send({ error: "Failed to fetch apps" });
      }
    }
  );

  // GET /admin/api/apps/:appId - Get app detail with repositories
  server.get<{
    Params: { appId: string };
    Reply: ApiResponse<AppDetail> | ApiErrorResponse;
  }>("/api/apps/:appId", async (request, reply) => {
    try {
      const { appId } = request.params;
      const app = await getAppById(appId);

      if (!app) {
        return reply.code(404).send({ error: "App not found" });
      }

      const repos = await listRepositoriesByApp(appId);
      const repositories: RepositorySummary[] = repos.map((repo) => ({
        repository_id: repo.repository_id,
        github_url: repo.github_url,
        owner: repo.owner,
        name: repo.name,
        status: repo.status as RepositorySummary["status"],
        last_scanned_at: repo.last_scanned_at?.toISOString() ?? null,
        circuit_open: repo.circuit_open,
      }));

      const apps = await listAppsWithCounts();
      const appWithCounts = apps.find((a) => a.app_id === appId);

      const response: AppDetail = {
        app_id: app.app_id,
        app_name: app.app_name,
        base_url: app.base_url,
        email: app.email,
        website: app.website,
        description: app.description,
        created_at: app.created_at.toISOString(),
        repository_count: appWithCounts?.repository_count ?? 0,
        failed_notification_count: appWithCounts?.failed_notification_count ?? 0,
        repositories,
      };

      return reply.send({ data: response });
    } catch (error) {
      console.error("Error fetching app detail:", error);
      return reply.code(500).send({ error: "Failed to fetch app detail" });
    }
  });

  // GET /admin/api/repositories - List all repositories
  server.get<{ Reply: ApiResponse<RepositorySummary[]> | ApiErrorResponse }>(
    "/api/repositories",
    async (_request, reply) => {
      try {
        const repos = await listAllRepositories();
        const response: RepositorySummary[] = repos.map((repo) => ({
          repository_id: repo.repository_id,
          github_url: repo.github_url,
          owner: repo.owner,
          name: repo.name,
          status: repo.status as RepositorySummary["status"],
          last_scanned_at: repo.last_scanned_at?.toISOString() ?? null,
          circuit_open: repo.circuit_open,
        }));
        return reply.send({ data: response });
      } catch (error) {
        console.error("Error fetching repositories:", error);
        return reply.code(500).send({ error: "Failed to fetch repositories" });
      }
    }
  );
}
```

2. Update `src/routes/admin/index.ts` to register dashboard API routes:

```typescript
import type { FastifyInstance } from "fastify";
import { authRoutes } from "./auth.js";
import { staticRoutes } from "./static.js";
import { dashboardApiRoutes } from "./dashboard-api.js";

export async function adminRoutes(server: FastifyInstance): Promise<void> {
  // Auth routes must be registered BEFORE static routes
  // to prevent SPA catch-all from intercepting API requests
  await server.register(authRoutes);
  await server.register(dashboardApiRoutes);
  await server.register(staticRoutes);
}
```
  </action>
  <verify>
1. Run `pnpm typecheck` to verify types
2. Run `pnpm build` to ensure compilation succeeds
  </verify>
  <done>Dashboard API routes registered at /admin/api/apps, /admin/api/apps/:appId, /admin/api/repositories with session auth protection</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm build` succeeds
3. Routes are registered in correct order (auth -> dashboard-api -> static)
4. All endpoints require session authentication
</verification>

<success_criteria>
- GET /admin/api/apps returns list of apps with repository and failure counts
- GET /admin/api/apps/:appId returns app detail with linked repositories
- GET /admin/api/repositories returns all repositories with status
- All endpoints return 401 for unauthenticated requests
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-dashboard-core-display/02-02-SUMMARY.md`
</output>
