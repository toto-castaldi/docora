---
phase: 02-dashboard-core-display
plan: 05
type: execute
wave: 2
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - dashboard/src/api/admin.ts
  - dashboard/src/hooks/usePolling.ts
  - dashboard/src/pages/Overview.tsx
  - dashboard/src/pages/Overview.module.css
  - dashboard/src/pages/Dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Overview page displays key metrics (apps, repos, failures, queue)"
    - "Data auto-refreshes every 10 seconds"
    - "Last updated indicator shows time since refresh"
    - "API errors show toast notification"
  artifacts:
    - path: "dashboard/src/api/admin.ts"
      provides: "API client functions"
      exports: ["fetchOverview", "fetchApps", "fetchRepositories"]
    - path: "dashboard/src/hooks/usePolling.ts"
      provides: "Shared polling configuration"
      exports: ["POLL_INTERVAL", "usePollingQuery"]
    - path: "dashboard/src/pages/Overview.tsx"
      provides: "Overview page component"
      contains: "OverviewMetrics"
  key_links:
    - from: "dashboard/src/pages/Overview.tsx"
      to: "dashboard/src/api/admin.ts"
      via: "useQuery with fetchOverview"
      pattern: "fetchOverview"
---

<objective>
Create API client layer, polling hooks, and Overview page with metrics display.

Purpose: Establish data fetching patterns and build the main dashboard landing page.
Output: API client functions, usePolling hook, Overview page showing apps/repos/failures/queue counts.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dashboard-core-display/02-CONTEXT.md
@.planning/phases/02-dashboard-core-display/02-RESEARCH.md
@dashboard/src/context/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API client and polling hook</name>
  <files>dashboard/src/api/admin.ts, dashboard/src/hooks/usePolling.ts</files>
  <action>
1. Create `dashboard/src/api/admin.ts`:

```typescript
import type {
  AppSummary,
  AppDetail,
  RepositorySummary,
  QueueStatus,
  QueueJob,
  FailedNotification,
  OverviewMetrics,
  ApiResponse,
  ApiErrorResponse,
} from "@docora/shared-types";

class ApiError extends Error {
  constructor(
    message: string,
    public status: number
  ) {
    super(message);
    this.name = "ApiError";
  }
}

async function fetchApi<T>(endpoint: string): Promise<T> {
  const response = await fetch(`/admin${endpoint}`, {
    credentials: "include",
  });

  if (!response.ok) {
    const errorData = (await response.json().catch(() => ({
      error: "Unknown error",
    }))) as ApiErrorResponse;
    throw new ApiError(errorData.error, response.status);
  }

  const data = (await response.json()) as ApiResponse<T>;
  return data.data;
}

export async function fetchOverview(): Promise<OverviewMetrics> {
  return fetchApi<OverviewMetrics>("/api/overview");
}

export async function fetchApps(): Promise<AppSummary[]> {
  return fetchApi<AppSummary[]>("/api/apps");
}

export async function fetchAppDetail(appId: string): Promise<AppDetail> {
  return fetchApi<AppDetail>(`/api/apps/${appId}`);
}

export async function fetchRepositories(): Promise<RepositorySummary[]> {
  return fetchApi<RepositorySummary[]>("/api/repositories");
}

export async function fetchQueue(): Promise<{
  status: QueueStatus;
  jobs: QueueJob[];
}> {
  return fetchApi<{ status: QueueStatus; jobs: QueueJob[] }>("/api/queue");
}

export async function fetchFailedNotifications(): Promise<FailedNotification[]> {
  return fetchApi<FailedNotification[]>("/api/notifications/failed");
}

export { ApiError };
```

2. Create `dashboard/src/hooks/usePolling.ts`:

```typescript
import { useQuery, type UseQueryOptions } from "@tanstack/react-query";
import toast from "react-hot-toast";
import { useEffect, useRef } from "react";
import { ApiError } from "../api/admin";

export const POLL_INTERVAL = 10_000; // 10 seconds

/**
 * Wrapper around useQuery with polling and error toast handling.
 * Shows toast on error, continues polling even when tab is hidden.
 */
export function usePollingQuery<TData>(
  queryKey: string[],
  queryFn: () => Promise<TData>,
  options?: Omit<UseQueryOptions<TData, Error>, "queryKey" | "queryFn">
) {
  const lastErrorRef = useRef<string | null>(null);

  const query = useQuery({
    queryKey,
    queryFn,
    refetchInterval: POLL_INTERVAL,
    refetchIntervalInBackground: true,
    ...options,
  });

  // Show toast on new errors (not on every poll failure)
  useEffect(() => {
    if (query.error) {
      const errorMessage =
        query.error instanceof ApiError
          ? query.error.message
          : "An error occurred";

      // Only show toast if error message changed
      if (lastErrorRef.current !== errorMessage) {
        lastErrorRef.current = errorMessage;
        toast.error(errorMessage);
      }
    } else {
      lastErrorRef.current = null;
    }
  }, [query.error]);

  return query;
}
```
  </action>
  <verify>Run `cd dashboard && pnpm typecheck` to verify types compile</verify>
  <done>API client with fetchOverview/fetchApps/fetchRepositories/fetchQueue/fetchFailedNotifications created, usePolling hook with 10s interval and error toast handling</done>
</task>

<task type="auto">
  <name>Task 2: Create Overview page with metrics cards</name>
  <files>dashboard/src/pages/Overview.tsx, dashboard/src/pages/Overview.module.css, dashboard/src/pages/Dashboard.tsx</files>
  <action>
1. Create `dashboard/src/pages/Overview.module.css`:

```css
.container {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.title {
  margin: 0;
  font-size: 1.5rem;
  font-weight: 600;
  color: #111827;
}

.refreshInfo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.refreshButton {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.375rem 0.75rem;
  background-color: white;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
  color: #374151;
  font-size: 0.875rem;
  cursor: pointer;
  transition: background-color 0.15s;
}

.refreshButton:hover:not(:disabled) {
  background-color: #f9fafb;
}

.refreshButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.metricsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.metricCard {
  background-color: white;
  border-radius: 0.5rem;
  padding: 1.25rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.metricLabel {
  margin: 0;
  font-size: 0.875rem;
  color: #6b7280;
  font-weight: 500;
}

.metricValue {
  margin: 0.5rem 0 0;
  font-size: 2rem;
  font-weight: 600;
  color: #111827;
}

.metricValueError {
  color: #dc2626;
}

.loadingState {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  color: #6b7280;
}

.spin {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
```

2. Create `dashboard/src/pages/Overview.tsx`:

```typescript
import { formatDistanceToNow } from "date-fns";
import { RefreshCw, Boxes, GitBranch, AlertCircle, Clock, Loader2 } from "lucide-react";
import { usePollingQuery } from "../hooks/usePolling";
import { fetchOverview } from "../api/admin";
import styles from "./Overview.module.css";

export function Overview() {
  const { data, isLoading, dataUpdatedAt, refetch, isFetching } = usePollingQuery(
    ["overview"],
    fetchOverview
  );

  const handleRefresh = () => {
    refetch();
  };

  if (isLoading) {
    return (
      <div className={styles.loadingState}>
        <Loader2 size={24} className={styles.spin} />
        <span style={{ marginLeft: "0.5rem" }}>Loading dashboard...</span>
      </div>
    );
  }

  const lastUpdated = dataUpdatedAt
    ? formatDistanceToNow(new Date(dataUpdatedAt), { addSuffix: true })
    : "never";

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <h1 className={styles.title}>Overview</h1>
        <div className={styles.refreshInfo}>
          <span>Updated {lastUpdated}</span>
          <button
            onClick={handleRefresh}
            disabled={isFetching}
            className={styles.refreshButton}
          >
            <RefreshCw size={14} className={isFetching ? styles.spin : ""} />
            Refresh
          </button>
        </div>
      </div>

      <div className={styles.metricsGrid}>
        <div className={styles.metricCard}>
          <p className={styles.metricLabel}>
            <Boxes size={16} style={{ marginRight: "0.5rem", verticalAlign: "text-bottom" }} />
            Registered Apps
          </p>
          <p className={styles.metricValue}>{data?.total_apps ?? 0}</p>
        </div>

        <div className={styles.metricCard}>
          <p className={styles.metricLabel}>
            <GitBranch size={16} style={{ marginRight: "0.5rem", verticalAlign: "text-bottom" }} />
            Monitored Repositories
          </p>
          <p className={styles.metricValue}>{data?.total_repositories ?? 0}</p>
        </div>

        <div className={styles.metricCard}>
          <p className={styles.metricLabel}>
            <AlertCircle size={16} style={{ marginRight: "0.5rem", verticalAlign: "text-bottom" }} />
            Failed Notifications
          </p>
          <p className={`${styles.metricValue} ${(data?.failed_notifications ?? 0) > 0 ? styles.metricValueError : ""}`}>
            {data?.failed_notifications ?? 0}
          </p>
        </div>

        <div className={styles.metricCard}>
          <p className={styles.metricLabel}>
            <Clock size={16} style={{ marginRight: "0.5rem", verticalAlign: "text-bottom" }} />
            Queue (Waiting / Active)
          </p>
          <p className={styles.metricValue}>
            {data?.queue_waiting ?? 0} / {data?.queue_active ?? 0}
          </p>
        </div>
      </div>
    </div>
  );
}
```

3. Update `dashboard/src/pages/Dashboard.tsx` to re-export Overview:

```typescript
// Dashboard.tsx now re-exports Overview for backward compatibility
// The route "/" uses Dashboard, which renders Overview content
export { Overview as Dashboard } from "./Overview";
```
  </action>
  <verify>
1. Run `cd dashboard && pnpm typecheck` to verify types
2. Run `cd dashboard && pnpm build` to ensure build succeeds
  </verify>
  <done>Overview page created with 4 metric cards (apps, repos, failures, queue), auto-polling every 10s, refresh button, and "Updated X ago" indicator</done>
</task>

</tasks>

<verification>
1. `cd dashboard && pnpm typecheck` passes
2. `cd dashboard && pnpm build` succeeds
3. Overview page displays 4 metric cards
4. Data auto-refreshes (useQuery with refetchInterval)
5. Last updated indicator shows relative time
6. Refresh button triggers manual refetch
</verification>

<success_criteria>
- API client functions work for all dashboard endpoints
- usePollingQuery hook wraps useQuery with 10s polling and error toasts
- Overview page shows apps count, repos count, failed notifications, queue waiting/active
- Failed notifications count shown in red when > 0
- Loading state shows spinner
- Last updated indicator shows "X seconds ago" format
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-dashboard-core-display/02-05-SUMMARY.md`
</output>
