---
phase: 05-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/src/components/ErrorFallback.tsx
  - dashboard/src/components/ErrorFallback.module.css
  - dashboard/src/App.tsx
  - dashboard/src/pages/Overview.tsx
  - dashboard/src/pages/Overview.module.css
  - dashboard/src/pages/Queue.tsx
  - dashboard/src/pages/Queue.module.css
autonomous: true

must_haves:
  truths:
    - "Unhandled React render errors show a recovery UI instead of a blank page"
    - "Overview page displays user-friendly message when API fetch fails"
    - "Queue page displays user-friendly message when API fetch fails"
    - "All pages show loading spinners during initial data fetch"
  artifacts:
    - path: "dashboard/src/components/ErrorFallback.tsx"
      provides: "Shared error fallback component for ErrorBoundary"
      exports: ["ErrorFallback"]
    - path: "dashboard/src/components/ErrorFallback.module.css"
      provides: "Styles for error fallback UI"
    - path: "dashboard/src/App.tsx"
      provides: "Top-level ErrorBoundary wrapping routes"
      contains: "ErrorBoundary"
    - path: "dashboard/src/pages/Overview.tsx"
      provides: "Error state for failed metric fetches"
      contains: "isError"
    - path: "dashboard/src/pages/Queue.tsx"
      provides: "Error state for failed queue fetches"
      contains: "isError"
  key_links:
    - from: "dashboard/src/App.tsx"
      to: "dashboard/src/components/ErrorFallback.tsx"
      via: "ErrorBoundary FallbackComponent prop"
      pattern: "FallbackComponent.*ErrorFallback"
    - from: "dashboard/src/pages/Overview.tsx"
      to: "usePollingQuery"
      via: "isError destructured from query result"
      pattern: "isError"
    - from: "dashboard/src/pages/Queue.tsx"
      to: "usePollingQuery"
      via: "isError destructured from query result"
      pattern: "isError"
---

<objective>
Add React error boundaries and error/empty state handling to frontend pages.

Purpose: Prevent blank page crashes from unhandled React rendering errors. Ensure Overview and Queue pages (the two pages identified in research as missing error states) display user-friendly error messages when API fetches fail, rather than failing silently with only toast notifications.

Output: ErrorBoundary wrapping all routes, ErrorFallback recovery component, error states on Overview and Queue pages.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-production-hardening/05-RESEARCH.md
@dashboard/src/App.tsx
@dashboard/src/pages/Overview.tsx
@dashboard/src/pages/Queue.tsx
@dashboard/src/pages/Overview.module.css
@dashboard/src/pages/Queue.module.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-error-boundary and create ErrorBoundary setup</name>
  <files>
    dashboard/src/components/ErrorFallback.tsx
    dashboard/src/components/ErrorFallback.module.css
    dashboard/src/App.tsx
  </files>
  <action>
1. **Install `react-error-boundary`:**
   ```bash
   pnpm --filter dashboard add react-error-boundary
   ```

2. **Create `dashboard/src/components/ErrorFallback.tsx`:**
   A shared error fallback component used by the top-level ErrorBoundary. Shows an error message with a "Try again" recovery button.

   ```tsx
   import { AlertTriangle } from "lucide-react";
   import styles from "./ErrorFallback.module.css";

   interface ErrorFallbackProps {
     error: Error;
     resetErrorBoundary: () => void;
   }

   export function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) {
     return (
       <div className={styles.container}>
         <AlertTriangle size={48} className={styles.icon} />
         <h2 className={styles.title}>Something went wrong</h2>
         <p className={styles.message}>{error.message}</p>
         <button onClick={resetErrorBoundary} className={styles.retryButton}>
           Try again
         </button>
       </div>
     );
   }
   ```

3. **Create `dashboard/src/components/ErrorFallback.module.css`:**
   Centered layout matching the existing dashboard style (white backgrounds, #111827 text, consistent with loading states):

   ```css
   .container {
     display: flex;
     flex-direction: column;
     align-items: center;
     justify-content: center;
     padding: 3rem;
     text-align: center;
     min-height: 300px;
   }

   .icon {
     color: #ef4444;
     margin-bottom: 1rem;
   }

   .title {
     font-size: 1.25rem;
     font-weight: 600;
     color: #111827;
     margin: 0 0 0.5rem;
   }

   .message {
     color: #6b7280;
     margin: 0 0 1.5rem;
     max-width: 400px;
   }

   .retryButton {
     display: inline-flex;
     align-items: center;
     gap: 0.375rem;
     padding: 0.5rem 1rem;
     font-size: 0.875rem;
     font-weight: 500;
     color: #fff;
     background: #3b82f6;
     border: none;
     border-radius: 0.375rem;
     cursor: pointer;
   }

   .retryButton:hover {
     background: #2563eb;
   }
   ```

4. **Update `dashboard/src/App.tsx`:**
   Wrap the routes inside `<Layout>` with an `ErrorBoundary` that uses `ErrorFallback` as fallback. Use the `useLocation` key pattern so that navigating to a different route resets the error boundary.

   Since `useLocation` requires being inside `BrowserRouter`, wrap the inner route tree in a separate component:

   ```tsx
   import { BrowserRouter, Routes, Route, useLocation } from "react-router";
   import { ErrorBoundary } from "react-error-boundary";
   import { AuthProvider } from "./context/AuthContext";
   import { ProtectedRoute } from "./components/ProtectedRoute";
   import { Layout } from "./components/Layout";
   import { ErrorFallback } from "./components/ErrorFallback";
   import { Login } from "./pages/Login";
   import { Dashboard } from "./pages/Dashboard";
   import { Apps } from "./pages/Apps";
   import { AppDetail } from "./pages/AppDetail";
   import { Repositories } from "./pages/Repositories";
   import { Notifications } from "./pages/Notifications";
   import { Queue } from "./pages/Queue";

   function AppRoutes() {
     const location = useLocation();
     return (
       <AuthProvider>
         <Routes>
           <Route path="/login" element={<Login />} />
           <Route element={<ProtectedRoute />}>
             <Route element={<Layout />}>
               <Route
                 index
                 element={
                   <ErrorBoundary FallbackComponent={ErrorFallback} resetKeys={[location.pathname]}>
                     <Dashboard />
                   </ErrorBoundary>
                 }
               />
               {/* Each page wrapped in its own ErrorBoundary so one page error
                   does not take down the entire layout/sidebar */}
             </Route>
           </Route>
         </Routes>
       </AuthProvider>
     );
   }
   ```

   Wait -- wrapping every individual route is verbose and breaks the clean route tree. Instead, wrap the entire route outlet area once. The `resetKeys={[location.pathname]}` ensures navigation resets the boundary.

   **Simpler approach:** Wrap the `<Layout />` outlet content area via a single ErrorBoundary around the routes inside Layout:

   Actually the cleanest approach: wrap routes with a single ErrorBoundary inside the Layout, using location.pathname as resetKey. But Layout uses `<Outlet />` so we need to wrap at the App level.

   **Final approach:** Create an `ErrorBoundaryWrapper` component that wraps its children with location-aware reset:

   ```tsx
   function ErrorBoundaryRoutes() {
     const location = useLocation();
     return (
       <ErrorBoundary FallbackComponent={ErrorFallback} resetKeys={[location.pathname]}>
         <AuthProvider>
           <Routes>
             <Route path="/login" element={<Login />} />
             <Route element={<ProtectedRoute />}>
               <Route element={<Layout />}>
                 <Route index element={<Dashboard />} />
                 <Route path="apps" element={<Apps />} />
                 <Route path="apps/:appId" element={<AppDetail />} />
                 <Route path="repositories" element={<Repositories />} />
                 <Route path="notifications" element={<Notifications />} />
                 <Route path="queue" element={<Queue />} />
               </Route>
             </Route>
           </Routes>
         </AuthProvider>
       </ErrorBoundary>
     );
   }

   export function App() {
     return (
       <BrowserRouter basename="/admin">
         <ErrorBoundaryRoutes />
       </BrowserRouter>
     );
   }
   ```

   This keeps the route tree clean. The ErrorBoundary wraps everything inside BrowserRouter (so `useLocation` works) and resets on navigation.
  </action>
  <verify>Run `pnpm --filter dashboard build` to confirm the dashboard compiles with the new dependency and components.</verify>
  <done>react-error-boundary installed. ErrorFallback component created with recovery button. App.tsx wraps routes in ErrorBoundary with location-based reset.</done>
</task>

<task type="auto">
  <name>Task 2: Add error states to Overview and Queue pages</name>
  <files>
    dashboard/src/pages/Overview.tsx
    dashboard/src/pages/Overview.module.css
    dashboard/src/pages/Queue.tsx
    dashboard/src/pages/Queue.module.css
  </files>
  <action>
Both Overview and Queue pages currently only show a loading spinner and then the data. If the API fetch fails, they show nothing useful (only a toast notification from usePollingQuery). Add explicit error state rendering.

1. **Update `dashboard/src/pages/Overview.tsx`:**
   Destructure `isError` from the `usePollingQuery` result. After the `isLoading` check, add an `isError` check that shows a centered error state with retry:

   ```tsx
   const { data, isLoading, isError, dataUpdatedAt, refetch, isFetching } =
     usePollingQuery(["overview"], fetchOverview);

   // ... after isLoading return ...

   if (isError) {
     return (
       <div className={styles.errorState}>
         <AlertCircle size={32} className={styles.errorIcon} />
         <p className={styles.errorMessage}>Failed to load dashboard metrics</p>
         <button onClick={() => refetch()} className={styles.retryButton}>
           Try again
         </button>
       </div>
     );
   }
   ```

   Import `AlertCircle` if not already imported (it IS already imported in Overview.tsx).

   Add CSS to `Overview.module.css`:
   ```css
   .errorState {
     display: flex;
     flex-direction: column;
     align-items: center;
     justify-content: center;
     padding: 3rem;
     text-align: center;
   }

   .errorIcon {
     color: #ef4444;
     margin-bottom: 0.75rem;
   }

   .errorMessage {
     color: #6b7280;
     margin: 0 0 1rem;
   }

   .retryButton {
     display: inline-flex;
     align-items: center;
     gap: 0.375rem;
     padding: 0.5rem 1rem;
     font-size: 0.875rem;
     font-weight: 500;
     color: #fff;
     background: #3b82f6;
     border: none;
     border-radius: 0.375rem;
     cursor: pointer;
   }

   .retryButton:hover {
     background: #2563eb;
   }
   ```

2. **Update `dashboard/src/pages/Queue.tsx`:**
   Same pattern -- destructure `isError` from usePollingQuery, add error check after isLoading:

   ```tsx
   const { data, isLoading, isError, dataUpdatedAt, refetch, isFetching } =
     usePollingQuery(["queue"], fetchQueue);

   // ... after isLoading return ...

   if (isError) {
     return (
       <div className={styles.errorState}>
         <AlertCircle size={32} className={styles.errorIcon} />
         <p className={styles.errorMessage}>Failed to load queue status</p>
         <button onClick={() => refetch()} className={styles.retryButton}>
           Try again
         </button>
       </div>
     );
   }
   ```

   Import `AlertCircle` from lucide-react (not currently imported in Queue.tsx -- add it to the import line).

   Add the same `.errorState`, `.errorIcon`, `.errorMessage`, `.retryButton` CSS classes to `Queue.module.css` (same styles as Overview).

**Note:** Other pages (Apps, Repositories, Notifications) already have adequate error/empty states from Phase 4 (they show "No matching results" when data is empty and have toast-based error handling). The research specifically identified Overview and Queue as the two pages with gaps.
  </action>
  <verify>Run `pnpm --filter dashboard build` to confirm both pages compile. Visually inspect that `isError` is destructured and used in both Overview.tsx and Queue.tsx.</verify>
  <done>Overview and Queue pages show centered error state with retry button when API fetch fails. Both pages retain existing loading spinners for initial load and toast notifications for background polling errors.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter dashboard build` succeeds
2. `react-error-boundary` appears in `dashboard/package.json` dependencies
3. ErrorFallback component exists at `dashboard/src/components/ErrorFallback.tsx`
4. App.tsx imports and uses ErrorBoundary with FallbackComponent={ErrorFallback}
5. Overview.tsx and Queue.tsx both destructure and render `isError` state
6. Error state CSS classes exist in both Overview.module.css and Queue.module.css
</verification>

<success_criteria>
- Unhandled render errors in any page show ErrorFallback with "Try again" button instead of blank page
- ErrorBoundary resets when navigating to a different route (resetKeys includes location.pathname)
- Overview error state shows "Failed to load dashboard metrics" with retry
- Queue error state shows "Failed to load queue status" with retry
- No regressions: existing loading states, empty states, and toast notifications still work
</success_criteria>

<output>
After completion, create `.planning/phases/05-production-hardening/05-02-SUMMARY.md`
</output>
