---
phase: 15-version-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/extract-version.cjs
  - src/version.ts
  - src/routes/version.ts
  - package.json
autonomous: true
requirements:
  - VER-01
  - VER-02
  - VER-03
  - VER-04
  - VER-05
  - VER-06

must_haves:
  truths:
    - "scripts/extract-version.cjs exists and is executable with Node"
    - "Running 'node scripts/extract-version.cjs' reads milestone from .planning/STATE.md frontmatter"
    - "The script generates src/version.ts with the version baked as a string literal (not resolved at runtime)"
    - "The script updates package.json version field to match the extracted milestone"
    - "The script prints just the version string to stdout (single line, e.g., '1.0+dev')"
    - "The script exits with code 1 if STATE.md is missing or milestone is unparseable"
    - "Local dev version format is '{major}.{minor}+dev' when BUILD_NUMBER and COMMIT_SHA are not set"
    - "CI version format is '{major}.{minor}+{buildNumber}.{shortSha}' when BUILD_NUMBER and COMMIT_SHA are set"
    - "GET /version returns flat { version, buildNumber, gitSha, buildDate } with no 'fake' field"
    - "GET /version is public (no auth required, like /health)"
    - "src/version.ts no longer resolves build info from process.env at runtime"
  artifacts:
    - path: "scripts/extract-version.cjs"
      provides: "Extract-version codegen script that reads STATE.md and writes version.ts + package.json"
      contains: "milestone"
    - path: "src/version.ts"
      provides: "Generated version module with baked version string"
      contains: "VERSION"
    - path: "src/routes/version.ts"
      provides: "Clean /version endpoint with flat response, no fake field"
      contains: "version"
    - path: "package.json"
      provides: "Version field synced by extract script"
      contains: "\"version\":"
  key_links:
    - from: "scripts/extract-version.cjs"
      to: "src/version.ts"
      via: "Script generates version.ts with baked version string"
      pattern: "writeFileSync.*version\\.ts"
    - from: "scripts/extract-version.cjs"
      to: "package.json"
      via: "Script syncs package.json version field"
      pattern: "writeFileSync.*package\\.json"
    - from: "src/routes/version.ts"
      to: "src/version.ts"
      via: "Route imports version constants from generated module"
      pattern: "import.*version"
---

<objective>
Create the extract-version codegen script and modernize the version infrastructure.

Purpose: Replace the old manual/CI-driven version management with a single codegen script that reads the milestone from STATE.md (the single source of truth), generates src/version.ts with baked values, syncs package.json, and prints the version for CI consumption. The /version API endpoint is cleaned up to return a flat, useful response.

Output: A working `scripts/extract-version.cjs` script, a regenerated `src/version.ts`, a clean `/version` route, and package.json version synced.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-version-infrastructure/15-CONTEXT.md
@src/version.ts
@src/routes/version.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/extract-version.cjs</name>
  <files>scripts/extract-version.cjs</files>
  <action>
Create directory `scripts/` and file `scripts/extract-version.cjs`.

This is a CommonJS script (`.cjs`) so it runs with plain `node` without ESM configuration. It uses only Node built-in modules (fs, path).

**Behavior:**

1. **Read STATE.md** — Read `.planning/STATE.md` from the project root (relative to the script's location: `path.resolve(__dirname, '..', '.planning', 'STATE.md')`).

2. **Parse milestone** — Extract the `milestone` field from the YAML frontmatter (between `---` markers). The field format is `milestone: v{major}.{minor}` (e.g., `milestone: v1.0` or `milestone: v1.3`). Parse the version number by stripping the `v` prefix. Use a regex like `/^milestone:\s*v(\d+\.\d+)/m` on the frontmatter text.

3. **Fail hard** — If STATE.md doesn't exist or the milestone can't be parsed, print an error to stderr and exit with code 1. No fallback values.

4. **Determine suffix** — Check environment variables:
   - If both `BUILD_NUMBER` and `COMMIT_SHA` are set: suffix = `+{BUILD_NUMBER}.{COMMIT_SHA first 7 chars}` (CI format)
   - Otherwise: suffix = `+dev` (local format)

5. **Build version string** — `{major}.{minor}{suffix}` (e.g., `1.3+dev` or `1.3+108.a3bc02d`)

6. **Generate src/version.ts** — Write to `src/version.ts` (path relative to project root):
   ```typescript
   /**
    * Docora Version — Generated by scripts/extract-version.cjs
    * Do not edit manually. Run: node scripts/extract-version.cjs
    */
   export const VERSION = "{versionString}";

   export const BUILD_INFO = {
     version: "{versionString}",
     buildNumber: "{buildNumber or 'dev'}",
     gitSha: "{shortSha or 'local'}",
     buildDate: "{ISO date string at generation time}",
   } as const;

   export type BuildInfo = typeof BUILD_INFO;
   ```
   All values are baked as string literals — no `process.env` references.

7. **Sync package.json** — Read `package.json`, parse as JSON, set `version` to the base version without suffix (just `{major}.{minor}.0` to satisfy semver requirements of package.json — e.g., `1.0.0`). Write back with 2-space indent + trailing newline. Keep the `+suffix` out of package.json since npm version fields must be valid semver.

8. **Print to stdout** — Print just the full version string (e.g., `1.0+dev`) as a single line. This is the only stdout output — all errors and status messages go to stderr.

**Error handling:**
- File not found → stderr message + exit 1
- Milestone not parseable → stderr message + exit 1
- Write failures → let Node's default error propagate (exit non-zero)

The script should be around 60-80 lines, clean and readable.
  </action>
  <verify>Run `node scripts/extract-version.cjs` and verify: (1) it prints a version string like `1.0+dev` to stdout, (2) `src/version.ts` has been regenerated with baked values and no `process.env`, (3) `package.json` version is updated to `1.0.0`. Then test failure: `mv .planning/STATE.md .planning/STATE.md.bak && node scripts/extract-version.cjs; echo "exit: $?"; mv .planning/STATE.md.bak .planning/STATE.md` — should exit with code 1.</verify>
  <done>scripts/extract-version.cjs created. It reads milestone from STATE.md, generates src/version.ts with baked values, syncs package.json version, and prints version to stdout. Fails hard on missing/invalid STATE.md.</done>
</task>

<task type="auto">
  <name>Task 2: Clean up /version route to return flat response</name>
  <files>src/routes/version.ts</files>
  <action>
Edit `src/routes/version.ts` to return a flat response structure.

**Current state:** The route returns `{ version, full, details: BUILD_INFO, fake: "3" }` with nested structure and a stale `fake` field.

**Target state:** The route returns a flat object:
```typescript
{
  version: BUILD_INFO.version,
  buildNumber: BUILD_INFO.buildNumber,
  gitSha: BUILD_INFO.gitSha,
  buildDate: BUILD_INFO.buildDate,
}
```

**Changes:**
1. Import only `BUILD_INFO` from `../version.js` (remove `getVersionString` and `getFullVersionString` imports — these helper functions are no longer needed since the version string is baked in).
2. Return the flat response object with the four fields directly from BUILD_INFO.
3. Remove the `fake` field entirely.
4. Keep `config: { publicAccess: true }` — this endpoint remains public.

After editing, also verify that `getVersionString` and `getFullVersionString` are not imported anywhere else in the codebase. If they are not used elsewhere, they can stay in version.ts for now (the extract script already removed them from the generated file in Task 1). If they ARE used elsewhere, update those references to use `BUILD_INFO.version` directly.
  </action>
  <verify>Run `pnpm typecheck` to verify no type errors. Then grep for any remaining imports of `getVersionString` or `getFullVersionString` or references to `fake` in the routes: `grep -r "getVersionString\|getFullVersionString\|fake" src/ --include="*.ts"` — should return nothing from routes, and only from version.ts if the helpers still exist there (they shouldn't after Task 1's regeneration).</verify>
  <done>/version route returns flat { version, buildNumber, gitSha, buildDate } response. No fake field. No helper function imports. Public access preserved.</done>
</task>

</tasks>

<verification>
1. `node scripts/extract-version.cjs` succeeds and prints version string (e.g., `1.0+dev`) to stdout
2. `src/version.ts` contains baked string literals, no `process.env` references
3. `package.json` version field matches `{major}.{minor}.0` (e.g., `1.0.0`)
4. `pnpm typecheck` passes with no errors
5. `scripts/extract-version.cjs` exits 1 when STATE.md is missing
6. `/version` route code returns flat `{ version, buildNumber, gitSha, buildDate }` with no `fake` field
7. No imports of `getVersionString` or `getFullVersionString` remain in route files
</verification>

<success_criteria>
- Running `node scripts/extract-version.cjs` reads the milestone from STATE.md and generates `src/version.ts` with the version baked in
- After running the extract script, `package.json` version field matches the extracted milestone version
- The extract script prints the version string to stdout (consumable by CI)
- GET /version returns a response with the milestone-derived version and no stale `fake` field
- Version format is `1.0+dev` locally and `1.3+108.a3bc02d` in CI
</success_criteria>

<output>
After completion, create `.planning/phases/15-version-infrastructure/15-01-SUMMARY.md`
</output>
