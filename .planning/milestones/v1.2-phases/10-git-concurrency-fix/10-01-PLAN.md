---
phase: 10-git-concurrency-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - src/services/repo-lock.ts
  - src/workers/snapshot.worker.ts
  - src/services/repository-management.ts
  - tests/services/repo-lock.test.ts
autonomous: true
requirements:
  - RACE-01

must_haves:
  truths:
    - "Two concurrent snapshot jobs for the same repo are serialized (only one holds the lock at a time)"
    - "Two concurrent snapshot jobs for different repos execute in parallel (per-repo lock keys)"
    - "If a git operation fails mid-lock, the mutex is released and subsequent operations proceed"
    - "Lock timeout throws a distinct LockTimeoutError that BullMQ retries"
    - "deleteLocalRepository is also protected by the same per-repo lock"
  artifacts:
    - path: "src/services/repo-lock.ts"
      provides: "Redis-based per-repo distributed mutex using Redlock"
      exports: ["withRepoLock", "LockTimeoutError", "shutdownRepoLock"]
    - path: "tests/services/repo-lock.test.ts"
      provides: "Unit tests for lock acquire, release, timeout, and error propagation"
      min_lines: 50
  key_links:
    - from: "src/workers/snapshot.worker.ts"
      to: "src/services/repo-lock.ts"
      via: "withRepoLock wrapping cloneOrPull call"
      pattern: "withRepoLock.*cloneOrPull"
    - from: "src/services/repository-management.ts"
      to: "src/services/repo-lock.ts"
      via: "withRepoLock wrapping deleteLocalRepository call"
      pattern: "withRepoLock.*deleteLocalRepository"
    - from: "src/services/repo-lock.ts"
      to: "src/queue/connection.ts"
      via: "getRedisConnection for Redlock client"
      pattern: "getRedisConnection|createRedisConnection"
---

<objective>
Serialize git operations per repository path using a Redis-based distributed mutex to prevent corruption under concurrent BullMQ jobs.

Purpose: Two apps watching the same repo can run snapshot jobs concurrently without git index.lock conflicts or wrong-token fetches. Different repos remain fully parallel.
Output: `src/services/repo-lock.ts` module with `withRepoLock` function, integrated into snapshot worker and repository-management unwatch flow.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-git-concurrency-fix/10-CONTEXT.md
@.planning/phases/10-git-concurrency-fix/10-RESEARCH.md
@src/services/git.ts
@src/workers/snapshot.worker.ts
@src/services/repository-management.ts
@src/queue/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repo-lock service with Redlock and tests</name>
  <files>
    package.json
    pnpm-lock.yaml
    src/services/repo-lock.ts
    tests/services/repo-lock.test.ts
  </files>
  <action>
1. Install redlock: `pnpm add redlock`

2. Create `src/services/repo-lock.ts` with:
   - Import `Redlock`, `ExecutionError` from "redlock" and `createRedisConnection` from "../queue/connection.js"
   - Constants (configurable via env vars with defaults):
     - `LOCK_TTL_MS = 120_000` (120s auto-expiry, longer than wait timeout)
     - `LOCK_RETRY_COUNT = 30` (30 retries)
     - `LOCK_RETRY_DELAY_MS = 2000` (2s between retries = 60s total wait window)
     - `LOCK_RETRY_JITTER_MS = 400` (jitter to avoid thundering herd)
   - `LockTimeoutError` class extending Error with `name = "LockTimeoutError"` and a `repoPath` property. This is a regular Error (NOT UnrecoverableError) so BullMQ retries it.
   - Lazy singleton `getRedlock()` function that creates a Redlock instance using a DEDICATED Redis connection (call `createRedisConnection()`, not `getRedisConnection()` — Redlock needs its own connection to avoid blocking BullMQ's connection). Attach error listener that ignores `ResourceLockedError` (expected during contention) and logs others.
   - `withRepoLock<T>(repoPath: string, jobId: string, fn: () => Promise<T>): Promise<T>` function:
     - Build lock key: `docora:repo-lock:${repoPath}` (repoPath = `owner/name`)
     - Log at debug level: `[job:${jobId}] Acquiring lock on ${repoPath}`
     - Try to acquire lock via `getRedlock().acquire([lockKey], LOCK_TTL_MS)`
     - On acquire failure (catch `ExecutionError`): log at error level with jobId, throw new `LockTimeoutError(repoPath)`
     - On acquire success: log at debug level, run `fn()` in try/finally, release lock in finally block
     - Log release at debug level
   - `shutdownRepoLock()` async function: if redlock instance exists, call `redlock.quit()` and set to null. This is for graceful shutdown.

   IMPORTANT: Use `createRedisConnection()` (not `getRedisConnection()`) to create a dedicated Redis client for Redlock. The BullMQ shared connection must not be reused because Redlock's blocking retry behavior could interfere with queue operations.

3. Create `tests/services/repo-lock.test.ts` with:
   - Mock "redlock" module and "../src/queue/connection.js"
   - Test cases:
     a. "should acquire lock, run callback, and release" — mock successful acquire, verify callback runs, verify release called
     b. "should release lock even if callback throws" — mock successful acquire, callback throws, verify release still called, verify error propagates
     c. "should throw LockTimeoutError when acquire fails" — mock acquire to throw ExecutionError, verify LockTimeoutError is thrown with correct repoPath
     d. "should use correct lock key format" — verify acquire called with `["docora:repo-lock:owner/name"]`
     e. "LockTimeoutError should have correct name property" — verify `error.name === "LockTimeoutError"`
     f. "LockTimeoutError should not be an UnrecoverableError" — verify it is a plain Error, not an UnrecoverableError from bullmq (important for retry behavior)
   - Use `vi.mock()` for redlock, `vi.clearAllMocks()` in beforeEach
  </action>
  <verify>
    <automated>cd /home/toto/scm-projects/docora && pnpm test -- tests/services/repo-lock.test.ts</automated>
    <manual>Verify redlock appears in package.json dependencies</manual>
  </verify>
  <done>
    - `redlock` is installed in package.json dependencies
    - `src/services/repo-lock.ts` exports `withRepoLock`, `LockTimeoutError`, `shutdownRepoLock`
    - All 6 test cases pass covering: acquire/release lifecycle, error propagation, timeout behavior, lock key format, error type identity
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate repo lock into snapshot worker and repository management</name>
  <files>
    src/workers/snapshot.worker.ts
    src/services/repository-management.ts
  </files>
  <action>
1. Modify `src/workers/snapshot.worker.ts`:
   - Add import: `import { withRepoLock } from "../services/repo-lock.js";`
   - In `processSnapshotJob`, wrap the git clone/pull section (lines ~169-223, the try/catch around `cloneOrPull` AND `resetGitFailures`) inside `withRepoLock`:
     ```typescript
     const { localPath, commitSha, branch } = await withRepoLock(
       `${owner}/${name}`,
       job.id ?? "unknown",
       async () => {
         // existing try block for cloneOrPull
         const result = await cloneOrPull(github_url, owner, name, githubToken);
         await resetGitFailures(repository_id);
         return result;
       }
     );
     ```
   - The git error handling (catch block with circuit breaker logic) must REMAIN INSIDE the `withRepoLock` callback, because the lock must be held during the entire git operation including error recording. Restructure to:
     ```typescript
     const { localPath, commitSha, branch } = await withRepoLock(
       `${owner}/${name}`,
       job.id ?? "unknown",
       async () => {
         try {
           const result = await cloneOrPull(github_url, owner, name, githubToken);
           await resetGitFailures(repository_id);
           return result;
         } catch (gitError) {
           // ... existing circuit breaker logic ...
           throw gitError;
         }
       }
     );
     ```
   - Do NOT wrap the scan, notification, or snapshot save sections — only git operations need the lock. Holding the lock too long increases contention and TTL risk.
   - `LockTimeoutError` propagates up as a regular Error, causing BullMQ retry via the existing catch block (lines ~329-363). No special handling needed — the existing retry count logic and `pending_snapshot` status reset work correctly for lock timeouts.

2. Modify `src/services/repository-management.ts`:
   - Add import: `import { withRepoLock } from "./repo-lock.js";`
   - In `unwatchRepository`, wrap the `deleteLocalRepository` call inside `withRepoLock`:
     ```typescript
     if (orphan) {
       await deleteRepository(repositoryId);
       await withRepoLock(
         `${repoInfo.owner}/${repoInfo.name}`,
         `unwatch-${appId}`,
         async () => {
           deleteLocalRepository(repoInfo.owner, repoInfo.name);
         }
       );
     }
     ```
   - This prevents a race between a concurrent clone/pull and a directory deletion on the same repo path. The lock key `owner/name` matches the key used in the snapshot worker, ensuring mutual exclusion.
   - Note: `deleteRepository` (DB delete) stays OUTSIDE the lock — only the filesystem operation needs the lock. DB operations have their own transaction guarantees.

3. Verify both files stay under the 150-line guideline where possible. The snapshot worker is already long (~397 lines), so adding the withRepoLock wrapper is acceptable as it adds minimal lines (~5-8 net) and restructures existing code rather than adding new logic.
  </action>
  <verify>
    <automated>cd /home/toto/scm-projects/docora && pnpm typecheck</automated>
    <manual>Review that lock wraps ONLY git operations in snapshot worker, not scan/notify/save sections. Review that repository-management wraps ONLY the filesystem delete, not the DB delete.</manual>
  </verify>
  <done>
    - `snapshot.worker.ts` wraps `cloneOrPull` + `resetGitFailures` + circuit breaker logic inside `withRepoLock` with key `owner/name`
    - `repository-management.ts` wraps `deleteLocalRepository` inside `withRepoLock` with key `owner/name`
    - TypeScript compilation passes with no errors
    - Lock scope is minimal: only filesystem-touching git operations are locked
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` — all existing tests plus new repo-lock tests pass
2. `pnpm typecheck` — no TypeScript errors
3. `pnpm build` — compiles successfully
4. Code review: lock key in snapshot worker (`${owner}/${name}`) matches lock key in repository-management (`${repoInfo.owner}/${repoInfo.name}`) — same repo = same lock key
5. Code review: LockTimeoutError is NOT an UnrecoverableError — BullMQ will retry
6. Code review: lock scope covers git ops only, not scan/notify/save
</verification>

<success_criteria>
- Redlock library installed and repo-lock service module exists with withRepoLock, LockTimeoutError, shutdownRepoLock exports
- Snapshot worker serializes git operations per repo path via withRepoLock
- Repository-management serializes local repo deletion via withRepoLock with matching lock key
- All tests pass (existing + new repo-lock tests)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/10-git-concurrency-fix/10-01-SUMMARY.md`
</output>
