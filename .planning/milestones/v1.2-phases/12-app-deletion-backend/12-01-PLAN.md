---
phase: 12-app-deletion-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/app-deletion.ts
  - src/routes/admin/delete-app.ts
  - src/routes/admin/index.ts
  - tests/services/app-deletion.test.ts
  - tests/routes/admin/delete-app.test.ts
autonomous: true
requirements: [DEL-01]

must_haves:
  truths:
    - "Admin can delete an app via DELETE /admin/api/apps/:appId and all dependent records are removed"
    - "Shared repositories are preserved when another app still watches them"
    - "Orphaned repositories (and their local clones) are cleaned up after deletion"
    - "Pending BullMQ jobs for the deleted app are removed"
    - "Unauthenticated requests receive 401"
  artifacts:
    - path: "src/services/app-deletion.ts"
      provides: "deleteApp orchestrator service"
      exports: ["deleteApp", "DeleteAppResult"]
    - path: "src/routes/admin/delete-app.ts"
      provides: "DELETE /admin/api/apps/:appId route"
      exports: ["deleteAppRoute"]
    - path: "tests/services/app-deletion.test.ts"
      provides: "Unit tests for deletion service"
      contains: "deleteApp"
    - path: "tests/routes/admin/delete-app.test.ts"
      provides: "Integration tests for delete route auth"
      contains: "DELETE /admin/api/apps"
  key_links:
    - from: "src/routes/admin/delete-app.ts"
      to: "src/services/app-deletion.ts"
      via: "deleteApp() call"
      pattern: "deleteApp\\("
    - from: "src/services/app-deletion.ts"
      to: "src/repositories/repositories.ts"
      via: "findRepositoriesByAppId, isRepositoryOrphan, deleteRepository"
      pattern: "(findRepositoriesByAppId|isRepositoryOrphan|deleteRepository)\\("
    - from: "src/routes/admin/index.ts"
      to: "src/routes/admin/delete-app.ts"
      via: "route registration"
      pattern: "deleteAppRoute"
---

<objective>
Create the app deletion service and admin API route with full cascade cleanup.

Purpose: Implement DEL-01 — admin can delete an app with all dependent records (deliveries, repository links, app record) removed in a single transaction, with post-transaction orphan cleanup and pending BullMQ job removal.

Output: Working DELETE /admin/api/apps/:appId endpoint with cascade delete service, plus tests.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-app-deletion-backend/12-CONTEXT.md
@.planning/phases/12-app-deletion-backend/12-RESEARCH.md

@src/services/repository-management.ts
@src/services/admin-actions.ts
@src/repositories/repositories.ts
@src/repositories/apps.ts
@src/repositories/deliveries.ts
@src/routes/admin/dashboard-actions.ts
@src/routes/admin/onboard.ts
@src/routes/admin/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app deletion service and admin route</name>
  <files>
    src/services/app-deletion.ts
    src/routes/admin/delete-app.ts
    src/routes/admin/index.ts
  </files>
  <action>
**Service: `src/services/app-deletion.ts`**

Create `deleteApp(appId: string): Promise<DeleteAppResult>` service function.

Export an interface `DeleteAppResult`:
```typescript
export interface DeleteAppResult {
  deleted: boolean;
  repositories_unlinked: number;
  orphaned_repositories_cleaned: number;
}
```

Implementation flow:
1. Verify app exists: `SELECT app_id FROM apps WHERE app_id = :appId`. If not found, return `{ deleted: false, repositories_unlinked: 0, orphaned_repositories_cleaned: 0 }`.
2. Gather repos BEFORE deletion: use existing `findRepositoriesByAppId(appId)` from `repositories/repositories.ts`. Save the list for post-transaction cleanup.
3. DB transaction (Kysely `db.transaction().execute()`): Delete in FK-safe order:
   - `DELETE FROM app_delivered_files WHERE app_id = :appId`
   - `DELETE FROM app_repositories WHERE app_id = :appId`
   - `DELETE FROM apps WHERE app_id = :appId`
4. Post-transaction orphan cleanup (best-effort, outside transaction): For each repo from step 2:
   - Call `isRepositoryOrphan(repo.repository_id)` from repositories.ts
   - If orphaned: call `deleteRepository(repo.repository_id)` (handles snapshots + repo record)
   - Then wrapped in try/catch: `withRepoLock(owner/name, delete-app-appId, () => deleteLocalRepository(owner, name))`
   - On disk cleanup failure: `console.error(...)` and continue (per CONTEXT.md: best-effort, log and forget)
5. Proactive BullMQ pending job removal (best-effort): For each repo from step 2:
   - Construct jobId as `${appId}-${repo.repository_id}` (same pattern as admin-actions.ts)
   - Use `getQueue()` pattern from admin-actions.ts (lazy singleton Queue)
   - `const job = await queue.getJob(jobId)` — if found and state is "waiting" or "delayed", call `job.remove()`
   - Wrap in try/catch, log errors and continue
6. Return `{ deleted: true, repositories_unlinked: repos.length, orphaned_repositories_cleaned: cleanedCount }`

Import `getQueue` by creating a local lazy singleton following the same pattern as `admin-actions.ts` (private `let queue` variable + `getQueue()` function). Import `Queue` from "bullmq", `SNAPSHOT_QUEUE_NAME` and `SnapshotJobData` from the worker.

Import from existing modules:
- `findRepositoriesByAppId`, `isRepositoryOrphan`, `deleteRepository` from `../repositories/repositories.js`
- `deleteLocalRepository` from `./git.js`
- `withRepoLock` from `./repo-lock.js`
- `getDatabase` from `../db/index.js`
- `getRedisUrl`, `getRedisOptions` from `../queue/connection.js`

Add an `export async function closeDeleteQueue()` for cleanup (same pattern as `closeActionQueue` in admin-actions.ts).

**Route: `src/routes/admin/delete-app.ts`**

Follow the pattern from `dashboard-actions.ts` for session auth and `onboard.ts` for route structure.

Create `deleteAppRoute(server: FastifyInstance)`:
1. Add `onRequest` hook checking `request.session?.get("adminId")` — return 401 if missing (same pattern as dashboard-actions.ts)
2. Register `DELETE /admin/api/apps/:appId` route
3. Extract `appId` from `request.params`
4. Call `deleteApp(appId)` from the service
5. If `result.deleted === false`, return 404: `{ error: "App not found" }`
6. Return 200 with the result: `{ data: result }`

Use types from `@docora/shared-types` for `ApiResponse` and `ApiErrorResponse` if available, otherwise use inline types.

**Route registration: `src/routes/admin/index.ts`**

Add import for `deleteAppRoute` from `./delete-app.js` and register it with `await server.register(deleteAppRoute)` — place it after `dashboardActionRoutes` and before `staticRoutes`.
  </action>
  <verify>
    <automated>pnpm typecheck</automated>
    <manual>Verify the new route is registered and the service compiles</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - `deleteApp()` service exists with transaction cascade + orphan cleanup + pending job removal
    - `DELETE /admin/api/apps/:appId` route exists with session auth
    - Route is registered in admin route tree
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for deletion service and route</name>
  <files>
    tests/services/app-deletion.test.ts
    tests/routes/admin/delete-app.test.ts
  </files>
  <action>
**Service tests: `tests/services/app-deletion.test.ts`**

Mock all external dependencies using `vi.mock()`:
- `../../src/db/index.js` (getDatabase)
- `../../src/repositories/repositories.js` (findRepositoriesByAppId, isRepositoryOrphan, deleteRepository)
- `../../src/services/git.js` (deleteLocalRepository)
- `../../src/services/repo-lock.js` (withRepoLock — mock to execute the callback immediately)
- `../../src/queue/connection.js` (getRedisUrl, getRedisOptions)
- `bullmq` (Queue)

Test cases for `deleteApp`:

1. **"should return deleted:false when app does not exist"**
   - Mock getDatabase to return `executeTakeFirst() => undefined` for the existence check
   - Assert result is `{ deleted: false, repositories_unlinked: 0, orphaned_repositories_cleaned: 0 }`

2. **"should delete app with cascade in correct FK order"**
   - Mock app exists, findRepositoriesByAppId returns 1 repo, repo is NOT orphan
   - Mock transaction: capture the callback, verify deleteFrom calls are made in order: app_delivered_files, app_repositories, apps
   - Assert result has `deleted: true, repositories_unlinked: 1, orphaned_repositories_cleaned: 0`

3. **"should clean up orphaned repository and local clone"**
   - Mock app exists, findRepositoriesByAppId returns 1 repo, repo IS orphan
   - Assert `deleteRepository` was called with the repo ID
   - Assert `deleteLocalRepository` was called (via withRepoLock mock)
   - Assert result has `orphaned_repositories_cleaned: 1`

4. **"should log and continue when disk cleanup fails"**
   - Mock app exists, repo is orphan, `deleteLocalRepository` throws
   - Assert `deleteRepository` was still called (DB cleanup succeeds)
   - Assert result still shows `orphaned_repositories_cleaned: 1` (DB part succeeded)
   - Assert console.error was called

5. **"should remove pending BullMQ jobs"**
   - Mock app exists with 1 repo, mock Queue.getJob returns a job with state "waiting"
   - Assert `job.remove()` was called

Follow existing test patterns from `tests/services/repository-management.test.ts` for mock structure. Use `vi.clearAllMocks()` in `beforeEach`.

**Route tests: `tests/routes/admin/delete-app.test.ts`**

Follow the pattern from `tests/routes/admin/onboard.test.ts` for admin auth testing.

Mock `../../src/services/app-deletion.js` (deleteApp).

Test cases:

1. **"should return 401 for unauthenticated request"**
   - `server.inject({ method: 'DELETE', url: '/admin/api/apps/test-id' })` with no session
   - Assert 401

2. **"should return 200 with deletion result for authenticated admin"**
   - Set up session mock with adminId
   - Mock deleteApp to return `{ deleted: true, repositories_unlinked: 2, orphaned_repositories_cleaned: 1 }`
   - Assert 200 with the data envelope

3. **"should return 404 when app not found"**
   - Mock deleteApp to return `{ deleted: false, ... }`
   - Assert 404 with error message
  </action>
  <verify>
    <automated>pnpm test</automated>
    <manual>All new tests pass, no existing tests broken</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - Service tests cover: app not found, cascade order, orphan cleanup, disk failure resilience, BullMQ job removal
    - Route tests cover: auth enforcement (401), successful deletion (200), not found (404)
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm test` passes (all new + existing tests)
3. DELETE /admin/api/apps/:appId is registered and reachable
4. Deletion service performs cascade in FK-safe order within a transaction
5. Orphaned repos are cleaned up (DB + disk) with best-effort error handling
6. Pending BullMQ jobs are removed
</verification>

<success_criteria>
- Admin can delete an app via API with full cascade cleanup
- Shared repositories preserved when other apps watch them
- Orphaned repositories cleaned from DB and disk
- Pending jobs for deleted app removed from queue
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-app-deletion-backend/12-01-SUMMARY.md`
</output>
